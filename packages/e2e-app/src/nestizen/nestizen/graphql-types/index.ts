/**
 * -----------------------------------------------------------------------------
 * WARNING:
 * This file is auto-generated by @nestizen/graphql-plugin.
 * Changes to this file will be lost if the code is regenerated.
 * -----------------------------------------------------------------------------
 */

/* eslint-disable */ import { Field } from '@nestjs/graphql';
import { ObjectType } from '@nestjs/graphql';
import { ArgsType } from '@nestjs/graphql';
import { Type } from 'class-transformer';
import { Prisma } from '@prisma/client';
import { Int } from '@nestjs/graphql';
import { InputType } from '@nestjs/graphql';
import { Float } from '@nestjs/graphql';
import { HideField } from '@nestjs/graphql';
import { registerEnumType } from '@nestjs/graphql';
import { GraphQLJSON } from 'graphql-type-json';
import { Decimal } from '@prisma/client/runtime/library';
import { GraphQLDecimal } from 'prisma-graphql-type-decimal';
import { transformToDecimal } from 'prisma-graphql-type-decimal';
import { Transform } from 'class-transformer';
import { GraphQLBigInt } from 'graphql-scalars';

export enum UserScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  email = 'email',
  name = 'name',
  role = 'role',
  parentId = 'parentId',
  mappedField = 'mappedField',
}

export enum TagScalarFieldEnum {
  key = 'key',
}

export enum ProfileScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  bio = 'bio',
  userId = 'userId',
}

export enum UserRole {
  USER = 'USER',
  ADMIN = 'ADMIN',
  MODERATOR = 'MODERATOR',
}

export enum TransactionIsolationLevel {
  ReadUncommitted = 'ReadUncommitted',
  ReadCommitted = 'ReadCommitted',
  RepeatableRead = 'RepeatableRead',
  Serializable = 'Serializable',
}

export enum SortOrder {
  asc = 'asc',
  desc = 'desc',
}

export enum QueryMode {
  'default' = 'default',
  insensitive = 'insensitive',
}

export enum PostKind {
  BLOG = 'BLOG',
  ADVERT = 'ADVERT',
}

export enum NullsOrder {
  first = 'first',
  last = 'last',
}

export enum JsonNullValueInput {
  JsonNull = 'JsonNull',
}

export enum JsonNullValueFilter {
  DbNull = 'DbNull',
  JsonNull = 'JsonNull',
  AnyNull = 'AnyNull',
}

export enum PostScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  title = 'title',
  content = 'content',
  published = 'published',
  authorId = 'authorId',
  anotherAuthorId = 'anotherAuthorId',
  postKind = 'postKind',
}

export enum MiscModelScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  name = 'name',
  jsonField = 'jsonField',
  jsonList = 'jsonList',
  stringList = 'stringList',
  decimalField = 'decimalField',
  decimalList = 'decimalList',
  floatField = 'floatField',
  bytesField = 'bytesField',
  bytesList = 'bytesList',
  bigIntField = 'bigIntField',
  bigIntList = 'bigIntList',
  dateTimeField = 'dateTimeField',
  dateTimeList = 'dateTimeList',
}

export enum HiddenModelScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  data = 'data',
}

export enum CategoryMetadataScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  categoryId = 'categoryId',
  metadata = 'metadata',
}

export enum CategoryScalarFieldEnum {
  id = 'id',
  createdAt = 'createdAt',
  updatedAt = 'updatedAt',
  name = 'name',
}

registerEnumType(CategoryScalarFieldEnum, {
  name: 'CategoryScalarFieldEnum',
  description: undefined,
});
registerEnumType(CategoryMetadataScalarFieldEnum, {
  name: 'CategoryMetadataScalarFieldEnum',
  description: undefined,
});
registerEnumType(HiddenModelScalarFieldEnum, {
  name: 'HiddenModelScalarFieldEnum',
  description: undefined,
});
registerEnumType(MiscModelScalarFieldEnum, {
  name: 'MiscModelScalarFieldEnum',
  description: undefined,
});
registerEnumType(PostScalarFieldEnum, {
  name: 'PostScalarFieldEnum',
  description: undefined,
});
registerEnumType(JsonNullValueFilter, {
  name: 'JsonNullValueFilter',
  description: undefined,
});
registerEnumType(JsonNullValueInput, {
  name: 'JsonNullValueInput',
  description: undefined,
});
registerEnumType(NullsOrder, { name: 'NullsOrder', description: undefined });
registerEnumType(PostKind, { name: 'PostKind', description: undefined });
registerEnumType(QueryMode, { name: 'QueryMode', description: undefined });
registerEnumType(SortOrder, { name: 'SortOrder', description: undefined });
registerEnumType(TransactionIsolationLevel, {
  name: 'TransactionIsolationLevel',
  description: undefined,
});
registerEnumType(UserRole, {
  name: 'UserRole',
  description: 'UserRole Documentation',
});
registerEnumType(ProfileScalarFieldEnum, {
  name: 'ProfileScalarFieldEnum',
  description: undefined,
});
registerEnumType(TagScalarFieldEnum, {
  name: 'TagScalarFieldEnum',
  description: undefined,
});
registerEnumType(UserScalarFieldEnum, {
  name: 'UserScalarFieldEnum',
  description: undefined,
});

@ObjectType()
export class AggregateCategory {
  @Field(() => CategoryCountAggregate, { nullable: true })
  _count?: InstanceType<typeof CategoryCountAggregate>;
  @Field(() => CategoryAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof CategoryAvgAggregate>;
  @Field(() => CategorySumAggregate, { nullable: true })
  _sum?: InstanceType<typeof CategorySumAggregate>;
  @Field(() => CategoryMinAggregate, { nullable: true })
  _min?: InstanceType<typeof CategoryMinAggregate>;
  @Field(() => CategoryMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof CategoryMaxAggregate>;
}

@ArgsType()
export class CategoryAggregateArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryOrderByWithRelationInput>;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => CategoryCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof CategoryCountAggregateInput>;
  @Field(() => CategoryAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof CategoryAvgAggregateInput>;
  @Field(() => CategorySumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof CategorySumAggregateInput>;
  @Field(() => CategoryMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof CategoryMinAggregateInput>;
  @Field(() => CategoryMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof CategoryMaxAggregateInput>;
}

@InputType()
export class CategoryAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
}

@ObjectType()
export class CategoryAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
}

@InputType()
export class CategoryAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
}

@InputType()
export class CategoryCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class CategoryCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  name!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class CategoryCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
}

@ObjectType()
export class CategoryCount {
  @Field(() => Int, { nullable: false })
  posts?: number;
}

@InputType()
export class CategoryCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
}

@InputType()
export class CategoryCreateNestedManyWithoutPostsInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateWithoutPostsInput)
  create?: Array<CategoryCreateWithoutPostsInput>;
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateOrConnectWithoutPostsInput)
  connectOrCreate?: Array<CategoryCreateOrConnectWithoutPostsInput>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
}

@InputType()
export class CategoryCreateNestedOneWithoutMetadataInput {
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: true })
  @Type(() => CategoryCreateWithoutMetadataInput)
  create?: InstanceType<typeof CategoryCreateWithoutMetadataInput>;
  @Field(() => CategoryCreateOrConnectWithoutMetadataInput, { nullable: true })
  @Type(() => CategoryCreateOrConnectWithoutMetadataInput)
  connectOrCreate?: InstanceType<
    typeof CategoryCreateOrConnectWithoutMetadataInput
  >;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  connect?: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
}

@InputType()
export class CategoryCreateOrConnectWithoutMetadataInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: false })
  @Type(() => CategoryCreateWithoutMetadataInput)
  create!: InstanceType<typeof CategoryCreateWithoutMetadataInput>;
}

@InputType()
export class CategoryCreateOrConnectWithoutPostsInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => CategoryCreateWithoutPostsInput, { nullable: false })
  @Type(() => CategoryCreateWithoutPostsInput)
  create!: InstanceType<typeof CategoryCreateWithoutPostsInput>;
}

@InputType()
export class CategoryCreateWithoutMetadataInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => PostCreateNestedManyWithoutCategoriesInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutCategoriesInput>;
}

@InputType()
export class CategoryCreateWithoutPostsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => CategoryMetadataCreateNestedOneWithoutCategoryInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataCreateNestedOneWithoutCategoryInput
  >;
}

@InputType()
export class CategoryCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => PostCreateNestedManyWithoutCategoriesInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutCategoriesInput>;
  @Field(() => CategoryMetadataCreateNestedOneWithoutCategoryInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataCreateNestedOneWithoutCategoryInput
  >;
}

@ArgsType()
export class CategoryGroupByArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => [CategoryOrderByWithAggregationInput], { nullable: true })
  orderBy?: Array<CategoryOrderByWithAggregationInput>;
  @Field(() => [CategoryScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof CategoryScalarFieldEnum>;
  @Field(() => CategoryScalarWhereWithAggregatesInput, { nullable: true })
  having?: InstanceType<typeof CategoryScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => CategoryCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof CategoryCountAggregateInput>;
  @Field(() => CategoryAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof CategoryAvgAggregateInput>;
  @Field(() => CategorySumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof CategorySumAggregateInput>;
  @Field(() => CategoryMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof CategoryMinAggregateInput>;
  @Field(() => CategoryMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof CategoryMaxAggregateInput>;
}

@ObjectType()
export class CategoryGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => CategoryCountAggregate, { nullable: true })
  _count?: InstanceType<typeof CategoryCountAggregate>;
  @Field(() => CategoryAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof CategoryAvgAggregate>;
  @Field(() => CategorySumAggregate, { nullable: true })
  _sum?: InstanceType<typeof CategorySumAggregate>;
  @Field(() => CategoryMinAggregate, { nullable: true })
  _min?: InstanceType<typeof CategoryMinAggregate>;
  @Field(() => CategoryMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof CategoryMaxAggregate>;
}

@InputType()
export class CategoryListRelationFilter {
  @Field(() => CategoryWhereInput, { nullable: true })
  every?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => CategoryWhereInput, { nullable: true })
  some?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => CategoryWhereInput, { nullable: true })
  none?: InstanceType<typeof CategoryWhereInput>;
}

@InputType()
export class CategoryMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
}

@ObjectType()
export class CategoryMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  name?: string;
}

@InputType()
export class CategoryMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
}

@InputType()
export class CategoryMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
}

@ObjectType()
export class CategoryMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  name?: string;
}

@InputType()
export class CategoryMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
}

@InputType()
export class CategoryOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: keyof typeof SortOrder;
}

@InputType()
export class CategoryOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => CategoryCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof CategoryCountOrderByAggregateInput>;
  @Field(() => CategoryAvgOrderByAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof CategoryAvgOrderByAggregateInput>;
  @Field(() => CategoryMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof CategoryMaxOrderByAggregateInput>;
  @Field(() => CategoryMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof CategoryMinOrderByAggregateInput>;
  @Field(() => CategorySumOrderByAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof CategorySumOrderByAggregateInput>;
}

@InputType()
export class CategoryOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => PostOrderByRelationAggregateInput, { nullable: true })
  posts?: InstanceType<typeof PostOrderByRelationAggregateInput>;
  @Field(() => CategoryMetadataOrderByWithRelationInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataOrderByWithRelationInput>;
}

@InputType()
export class CategoryRelationFilter {
  @Field(() => CategoryWhereInput, { nullable: true })
  is?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => CategoryWhereInput, { nullable: true })
  isNot?: InstanceType<typeof CategoryWhereInput>;
}

@InputType()
export class CategoryScalarWhereWithAggregatesInput {
  @Field(() => [CategoryScalarWhereWithAggregatesInput], { nullable: true })
  AND?: Array<CategoryScalarWhereWithAggregatesInput>;
  @Field(() => [CategoryScalarWhereWithAggregatesInput], { nullable: true })
  OR?: Array<CategoryScalarWhereWithAggregatesInput>;
  @Field(() => [CategoryScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: Array<CategoryScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  name?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class CategoryScalarWhereInput {
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  AND?: Array<CategoryScalarWhereInput>;
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  OR?: Array<CategoryScalarWhereInput>;
  @Field(() => [CategoryScalarWhereInput], { nullable: true })
  NOT?: Array<CategoryScalarWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
}

@InputType()
export class CategorySumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
}

@ObjectType()
export class CategorySumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
}

@InputType()
export class CategorySumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
}

@InputType()
export class CategoryUncheckedCreateNestedManyWithoutPostsInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateWithoutPostsInput)
  create?: Array<CategoryCreateWithoutPostsInput>;
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateOrConnectWithoutPostsInput)
  connectOrCreate?: Array<CategoryCreateOrConnectWithoutPostsInput>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
}

@InputType()
export class CategoryUncheckedCreateWithoutMetadataInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutCategoriesInput, {
    nullable: true,
  })
  posts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutCategoriesInput
  >;
}

@InputType()
export class CategoryUncheckedCreateWithoutPostsInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => CategoryMetadataUncheckedCreateNestedOneWithoutCategoryInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataUncheckedCreateNestedOneWithoutCategoryInput
  >;
}

@InputType()
export class CategoryUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutCategoriesInput, {
    nullable: true,
  })
  posts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutCategoriesInput
  >;
  @Field(() => CategoryMetadataUncheckedCreateNestedOneWithoutCategoryInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataUncheckedCreateNestedOneWithoutCategoryInput
  >;
}

@InputType()
export class CategoryUncheckedUpdateManyWithoutPostsNestedInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateWithoutPostsInput)
  create?: Array<CategoryCreateWithoutPostsInput>;
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateOrConnectWithoutPostsInput)
  connectOrCreate?: Array<CategoryCreateOrConnectWithoutPostsInput>;
  @HideField()
  upsert?: Array<CategoryUpsertWithWhereUniqueWithoutPostsInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryUpdateWithWhereUniqueWithoutPostsInput], {
    nullable: true,
  })
  @Type(() => CategoryUpdateWithWhereUniqueWithoutPostsInput)
  update?: Array<CategoryUpdateWithWhereUniqueWithoutPostsInput>;
  @HideField()
  updateMany?: Array<CategoryUpdateManyWithWhereWithoutPostsInput>;
  @HideField()
  deleteMany?: Array<CategoryScalarWhereInput>;
}

@InputType()
export class CategoryUncheckedUpdateManyWithoutPostsInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CategoryUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CategoryUncheckedUpdateWithoutMetadataInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutCategoriesNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutCategoriesNestedInput
  >;
}

@InputType()
export class CategoryUncheckedUpdateWithoutPostsInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUncheckedUpdateOneWithoutCategoryNestedInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataUncheckedUpdateOneWithoutCategoryNestedInput
  >;
}

@InputType()
export class CategoryUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutCategoriesNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutCategoriesNestedInput
  >;
  @Field(() => CategoryMetadataUncheckedUpdateOneWithoutCategoryNestedInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataUncheckedUpdateOneWithoutCategoryNestedInput
  >;
}

@InputType()
export class CategoryUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class CategoryUpdateManyWithWhereWithoutPostsInput {
  @Field(() => CategoryScalarWhereInput, { nullable: false })
  @Type(() => CategoryScalarWhereInput)
  where!: InstanceType<typeof CategoryScalarWhereInput>;
  @Field(() => CategoryUpdateManyMutationInput, { nullable: false })
  @Type(() => CategoryUpdateManyMutationInput)
  data!: InstanceType<typeof CategoryUpdateManyMutationInput>;
}

@InputType()
export class CategoryUpdateManyWithoutPostsNestedInput {
  @Field(() => [CategoryCreateWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateWithoutPostsInput)
  create?: Array<CategoryCreateWithoutPostsInput>;
  @Field(() => [CategoryCreateOrConnectWithoutPostsInput], { nullable: true })
  @Type(() => CategoryCreateOrConnectWithoutPostsInput)
  connectOrCreate?: Array<CategoryCreateOrConnectWithoutPostsInput>;
  @HideField()
  upsert?: Array<CategoryUpsertWithWhereUniqueWithoutPostsInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryWhereUniqueInput], { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>>;
  @Field(() => [CategoryUpdateWithWhereUniqueWithoutPostsInput], {
    nullable: true,
  })
  @Type(() => CategoryUpdateWithWhereUniqueWithoutPostsInput)
  update?: Array<CategoryUpdateWithWhereUniqueWithoutPostsInput>;
  @HideField()
  updateMany?: Array<CategoryUpdateManyWithWhereWithoutPostsInput>;
  @HideField()
  deleteMany?: Array<CategoryScalarWhereInput>;
}

@InputType()
export class CategoryUpdateOneRequiredWithoutMetadataNestedInput {
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: true })
  @Type(() => CategoryCreateWithoutMetadataInput)
  create?: InstanceType<typeof CategoryCreateWithoutMetadataInput>;
  @Field(() => CategoryCreateOrConnectWithoutMetadataInput, { nullable: true })
  @Type(() => CategoryCreateOrConnectWithoutMetadataInput)
  connectOrCreate?: InstanceType<
    typeof CategoryCreateOrConnectWithoutMetadataInput
  >;
  @HideField()
  upsert?: InstanceType<typeof CategoryUpsertWithoutMetadataInput>;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  @Type(() => CategoryWhereUniqueInput)
  connect?: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => CategoryUpdateToOneWithWhereWithoutMetadataInput, {
    nullable: true,
  })
  @Type(() => CategoryUpdateToOneWithWhereWithoutMetadataInput)
  update?: InstanceType<
    typeof CategoryUpdateToOneWithWhereWithoutMetadataInput
  >;
}

@InputType()
export class CategoryUpdateToOneWithWhereWithoutMetadataInput {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => CategoryUpdateWithoutMetadataInput, { nullable: false })
  @Type(() => CategoryUpdateWithoutMetadataInput)
  data!: InstanceType<typeof CategoryUpdateWithoutMetadataInput>;
}

@InputType()
export class CategoryUpdateWithWhereUniqueWithoutPostsInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => CategoryUpdateWithoutPostsInput, { nullable: false })
  @Type(() => CategoryUpdateWithoutPostsInput)
  data!: InstanceType<typeof CategoryUpdateWithoutPostsInput>;
}

@InputType()
export class CategoryUpdateWithoutMetadataInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutCategoriesNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutCategoriesNestedInput>;
}

@InputType()
export class CategoryUpdateWithoutPostsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdateOneWithoutCategoryNestedInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataUpdateOneWithoutCategoryNestedInput
  >;
}

@InputType()
export class CategoryUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutCategoriesNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutCategoriesNestedInput>;
  @Field(() => CategoryMetadataUpdateOneWithoutCategoryNestedInput, {
    nullable: true,
  })
  metadata?: InstanceType<
    typeof CategoryMetadataUpdateOneWithoutCategoryNestedInput
  >;
}

@InputType()
export class CategoryUpsertWithWhereUniqueWithoutPostsInput {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => CategoryUpdateWithoutPostsInput, { nullable: false })
  @Type(() => CategoryUpdateWithoutPostsInput)
  update!: InstanceType<typeof CategoryUpdateWithoutPostsInput>;
  @Field(() => CategoryCreateWithoutPostsInput, { nullable: false })
  @Type(() => CategoryCreateWithoutPostsInput)
  create!: InstanceType<typeof CategoryCreateWithoutPostsInput>;
}

@InputType()
export class CategoryUpsertWithoutMetadataInput {
  @Field(() => CategoryUpdateWithoutMetadataInput, { nullable: false })
  @Type(() => CategoryUpdateWithoutMetadataInput)
  update!: InstanceType<typeof CategoryUpdateWithoutMetadataInput>;
  @Field(() => CategoryCreateWithoutMetadataInput, { nullable: false })
  @Type(() => CategoryCreateWithoutMetadataInput)
  create!: InstanceType<typeof CategoryCreateWithoutMetadataInput>;
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
}

@InputType()
export class CategoryWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => String, { nullable: true })
  name!: string;
  @Field(() => [CategoryWhereInput], { nullable: true })
  AND?: Array<CategoryWhereInput>;
  @Field(() => [CategoryWhereInput], { nullable: true })
  OR?: Array<CategoryWhereInput>;
  @Field(() => [CategoryWhereInput], { nullable: true })
  NOT?: Array<CategoryWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts?: InstanceType<typeof PostListRelationFilter>;
  @Field(() => CategoryMetadataRelationFilter, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataRelationFilter>;
}

@InputType()
export class CategoryWhereInput {
  @Field(() => [CategoryWhereInput], { nullable: true })
  AND?: Array<CategoryWhereInput>;
  @Field(() => [CategoryWhereInput], { nullable: true })
  OR?: Array<CategoryWhereInput>;
  @Field(() => [CategoryWhereInput], { nullable: true })
  NOT?: Array<CategoryWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts?: InstanceType<typeof PostListRelationFilter>;
  @Field(() => CategoryMetadataRelationFilter, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataRelationFilter>;
}

@ObjectType()
export class Category {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  @Field(() => String, { nullable: false, description: '' })
  name!: string;
  /**
   * @graphql .hideResolveField
   * Many to many relation with Post
   */
  @Field(() => [Post], {
    nullable: true,
    description: '@graphql.hideResolveField\nMany to many relation with Post',
  })
  posts?: Array<Post>;
  /**
   * One to one relation with CategoryMetadata
   */
  @Field(() => CategoryMetadata, {
    nullable: true,
    description: 'One to one relation with CategoryMetadata',
  })
  metadata?: InstanceType<typeof CategoryMetadata> | null;
}

@ArgsType()
export class CreateManyCategoryArgs {
  @Field(() => [CategoryCreateManyInput], { nullable: false })
  @Type(() => CategoryCreateManyInput)
  data!: Array<CategoryCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCategoryArgs {
  @Field(() => CategoryCreateInput, { nullable: false })
  @Type(() => CategoryCreateInput)
  data!: InstanceType<typeof CategoryCreateInput>;
}

@ArgsType()
export class DeleteManyCategoryArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
}

@ArgsType()
export class DeleteOneCategoryArgs {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class FindFirstCategoryOrThrowArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryOrderByWithRelationInput>;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [CategoryScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof CategoryScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCategoryArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryOrderByWithRelationInput>;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [CategoryScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof CategoryScalarFieldEnum>;
}

@ArgsType()
export class FindManyCategoryArgs {
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
  @Field(() => [CategoryOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryOrderByWithRelationInput>;
  @Field(() => CategoryWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [CategoryScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof CategoryScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCategoryOrThrowArgs {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class FindUniqueCategoryArgs {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class UpdateManyCategoryArgs {
  @Field(() => CategoryUpdateManyMutationInput, { nullable: false })
  @Type(() => CategoryUpdateManyMutationInput)
  data!: InstanceType<typeof CategoryUpdateManyMutationInput>;
  @Field(() => CategoryWhereInput, { nullable: true })
  @Type(() => CategoryWhereInput)
  where?: InstanceType<typeof CategoryWhereInput>;
}

@ArgsType()
export class UpdateOneCategoryArgs {
  @Field(() => CategoryUpdateInput, { nullable: false })
  @Type(() => CategoryUpdateInput)
  data!: InstanceType<typeof CategoryUpdateInput>;
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
}

@ArgsType()
export class UpsertOneCategoryArgs {
  @Field(() => CategoryWhereUniqueInput, { nullable: false })
  @Type(() => CategoryWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryWhereUniqueInput, 'id' | 'name'>;
  @Field(() => CategoryCreateInput, { nullable: false })
  @Type(() => CategoryCreateInput)
  create!: InstanceType<typeof CategoryCreateInput>;
  @Field(() => CategoryUpdateInput, { nullable: false })
  @Type(() => CategoryUpdateInput)
  update!: InstanceType<typeof CategoryUpdateInput>;
}

@ObjectType()
export class AggregateCategoryMetadata {
  @Field(() => CategoryMetadataCountAggregate, { nullable: true })
  _count?: InstanceType<typeof CategoryMetadataCountAggregate>;
  @Field(() => CategoryMetadataAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof CategoryMetadataAvgAggregate>;
  @Field(() => CategoryMetadataSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof CategoryMetadataSumAggregate>;
  @Field(() => CategoryMetadataMinAggregate, { nullable: true })
  _min?: InstanceType<typeof CategoryMetadataMinAggregate>;
  @Field(() => CategoryMetadataMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof CategoryMetadataMaxAggregate>;
}

@ArgsType()
export class CategoryMetadataAggregateArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryMetadataOrderByWithRelationInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => CategoryMetadataCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof CategoryMetadataCountAggregateInput>;
  @Field(() => CategoryMetadataAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof CategoryMetadataAvgAggregateInput>;
  @Field(() => CategoryMetadataSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof CategoryMetadataSumAggregateInput>;
  @Field(() => CategoryMetadataMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof CategoryMetadataMinAggregateInput>;
  @Field(() => CategoryMetadataMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof CategoryMetadataMaxAggregateInput>;
}

@InputType()
export class CategoryMetadataAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  categoryId?: true;
}

@ObjectType()
export class CategoryMetadataAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
  @Field(() => Float, { nullable: true })
  categoryId?: number;
}

@InputType()
export class CategoryMetadataAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
}

@InputType()
export class CategoryMetadataCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  categoryId?: true;
  @Field(() => Boolean, { nullable: true })
  metadata?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class CategoryMetadataCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  categoryId!: number;
  @Field(() => Int, { nullable: false })
  metadata!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class CategoryMetadataCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  metadata?: keyof typeof SortOrder;
}

@InputType()
export class CategoryMetadataCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => Int, { nullable: false })
  categoryId!: number;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataCreatemetadataInput>;
}

@InputType()
export class CategoryMetadataCreateNestedOneWithoutCategoryInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  @Type(() => CategoryMetadataCreateWithoutCategoryInput)
  create?: InstanceType<typeof CategoryMetadataCreateWithoutCategoryInput>;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  @Type(() => CategoryMetadataCreateOrConnectWithoutCategoryInput)
  connectOrCreate?: InstanceType<
    typeof CategoryMetadataCreateOrConnectWithoutCategoryInput
  >;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  @Type(() => CategoryMetadataWhereUniqueInput)
  connect?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
}

@InputType()
export class CategoryMetadataCreateOrConnectWithoutCategoryInput {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  @Type(() => CategoryMetadataWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryMetadataWhereUniqueInput, 'id' | 'categoryId'>;
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: false })
  @Type(() => CategoryMetadataCreateWithoutCategoryInput)
  create!: InstanceType<typeof CategoryMetadataCreateWithoutCategoryInput>;
}

@InputType()
export class CategoryMetadataCreateWithoutCategoryInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataCreatemetadataInput>;
}

@InputType()
export class CategoryMetadataCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataCreatemetadataInput>;
  @Field(() => CategoryCreateNestedOneWithoutMetadataInput, { nullable: false })
  category!: InstanceType<typeof CategoryCreateNestedOneWithoutMetadataInput>;
}

@InputType()
export class CategoryMetadataCreatemetadataInput {
  @Field(() => [GraphQLJSON], { nullable: false })
  set!: Array<any>;
}

@ArgsType()
export class CategoryMetadataGroupByArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataOrderByWithAggregationInput], {
    nullable: true,
  })
  orderBy?: Array<CategoryMetadataOrderByWithAggregationInput>;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof CategoryMetadataScalarFieldEnum>;
  @Field(() => CategoryMetadataScalarWhereWithAggregatesInput, {
    nullable: true,
  })
  having?: InstanceType<typeof CategoryMetadataScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => CategoryMetadataCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof CategoryMetadataCountAggregateInput>;
  @Field(() => CategoryMetadataAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof CategoryMetadataAvgAggregateInput>;
  @Field(() => CategoryMetadataSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof CategoryMetadataSumAggregateInput>;
  @Field(() => CategoryMetadataMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof CategoryMetadataMinAggregateInput>;
  @Field(() => CategoryMetadataMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof CategoryMetadataMaxAggregateInput>;
}

@ObjectType()
export class CategoryMetadataGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => Int, { nullable: false })
  categoryId!: number;
  @Field(() => [GraphQLJSON], { nullable: true })
  metadata?: Array<any>;
  @Field(() => CategoryMetadataCountAggregate, { nullable: true })
  _count?: InstanceType<typeof CategoryMetadataCountAggregate>;
  @Field(() => CategoryMetadataAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof CategoryMetadataAvgAggregate>;
  @Field(() => CategoryMetadataSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof CategoryMetadataSumAggregate>;
  @Field(() => CategoryMetadataMinAggregate, { nullable: true })
  _min?: InstanceType<typeof CategoryMetadataMinAggregate>;
  @Field(() => CategoryMetadataMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof CategoryMetadataMaxAggregate>;
}

@InputType()
export class CategoryMetadataMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  categoryId?: true;
}

@ObjectType()
export class CategoryMetadataMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => Int, { nullable: true })
  categoryId?: number;
}

@InputType()
export class CategoryMetadataMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
}

@InputType()
export class CategoryMetadataMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  categoryId?: true;
}

@ObjectType()
export class CategoryMetadataMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => Int, { nullable: true })
  categoryId?: number;
}

@InputType()
export class CategoryMetadataMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
}

@InputType()
export class CategoryMetadataOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  metadata?: keyof typeof SortOrder;
  @Field(() => CategoryMetadataCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof CategoryMetadataCountOrderByAggregateInput>;
  @Field(() => CategoryMetadataAvgOrderByAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof CategoryMetadataAvgOrderByAggregateInput>;
  @Field(() => CategoryMetadataMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof CategoryMetadataMaxOrderByAggregateInput>;
  @Field(() => CategoryMetadataMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof CategoryMetadataMinOrderByAggregateInput>;
  @Field(() => CategoryMetadataSumOrderByAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof CategoryMetadataSumOrderByAggregateInput>;
}

@InputType()
export class CategoryMetadataOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  metadata?: keyof typeof SortOrder;
  @Field(() => CategoryOrderByWithRelationInput, { nullable: true })
  category?: InstanceType<typeof CategoryOrderByWithRelationInput>;
}

@InputType()
export class CategoryMetadataRelationFilter {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  is?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  isNot?: InstanceType<typeof CategoryMetadataWhereInput>;
}

@InputType()
export class CategoryMetadataScalarWhereWithAggregatesInput {
  @Field(() => [CategoryMetadataScalarWhereWithAggregatesInput], {
    nullable: true,
  })
  AND?: Array<CategoryMetadataScalarWhereWithAggregatesInput>;
  @Field(() => [CategoryMetadataScalarWhereWithAggregatesInput], {
    nullable: true,
  })
  OR?: Array<CategoryMetadataScalarWhereWithAggregatesInput>;
  @Field(() => [CategoryMetadataScalarWhereWithAggregatesInput], {
    nullable: true,
  })
  NOT?: Array<CategoryMetadataScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  categoryId?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => JsonListFilter, { nullable: true })
  metadata?: InstanceType<typeof JsonListFilter>;
}

@InputType()
export class CategoryMetadataSumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  categoryId?: true;
}

@ObjectType()
export class CategoryMetadataSumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Int, { nullable: true })
  categoryId?: number;
}

@InputType()
export class CategoryMetadataSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  categoryId?: keyof typeof SortOrder;
}

@InputType()
export class CategoryMetadataUncheckedCreateNestedOneWithoutCategoryInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  @Type(() => CategoryMetadataCreateWithoutCategoryInput)
  create?: InstanceType<typeof CategoryMetadataCreateWithoutCategoryInput>;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  @Type(() => CategoryMetadataCreateOrConnectWithoutCategoryInput)
  connectOrCreate?: InstanceType<
    typeof CategoryMetadataCreateOrConnectWithoutCategoryInput
  >;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  @Type(() => CategoryMetadataWhereUniqueInput)
  connect?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
}

@InputType()
export class CategoryMetadataUncheckedCreateWithoutCategoryInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataCreatemetadataInput>;
}

@InputType()
export class CategoryMetadataUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => Int, { nullable: false })
  categoryId!: number;
  @Field(() => CategoryMetadataCreatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataCreatemetadataInput>;
}

@InputType()
export class CategoryMetadataUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataUpdatemetadataInput>;
}

@InputType()
export class CategoryMetadataUncheckedUpdateOneWithoutCategoryNestedInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  @Type(() => CategoryMetadataCreateWithoutCategoryInput)
  create?: InstanceType<typeof CategoryMetadataCreateWithoutCategoryInput>;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  @Type(() => CategoryMetadataCreateOrConnectWithoutCategoryInput)
  connectOrCreate?: InstanceType<
    typeof CategoryMetadataCreateOrConnectWithoutCategoryInput
  >;
  @HideField()
  upsert?: InstanceType<typeof CategoryMetadataUpsertWithoutCategoryInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  disconnect?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  delete?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  @Type(() => CategoryMetadataWhereUniqueInput)
  connect?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
  @Field(() => CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput, {
    nullable: true,
  })
  @Type(() => CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput)
  update?: InstanceType<
    typeof CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput
  >;
}

@InputType()
export class CategoryMetadataUncheckedUpdateWithoutCategoryInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataUpdatemetadataInput>;
}

@InputType()
export class CategoryMetadataUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  categoryId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataUpdatemetadataInput>;
}

@InputType()
export class CategoryMetadataUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataUpdatemetadataInput>;
}

@InputType()
export class CategoryMetadataUpdateOneWithoutCategoryNestedInput {
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: true })
  @Type(() => CategoryMetadataCreateWithoutCategoryInput)
  create?: InstanceType<typeof CategoryMetadataCreateWithoutCategoryInput>;
  @Field(() => CategoryMetadataCreateOrConnectWithoutCategoryInput, {
    nullable: true,
  })
  @Type(() => CategoryMetadataCreateOrConnectWithoutCategoryInput)
  connectOrCreate?: InstanceType<
    typeof CategoryMetadataCreateOrConnectWithoutCategoryInput
  >;
  @HideField()
  upsert?: InstanceType<typeof CategoryMetadataUpsertWithoutCategoryInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  disconnect?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  delete?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  @Type(() => CategoryMetadataWhereUniqueInput)
  connect?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
  @Field(() => CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput, {
    nullable: true,
  })
  @Type(() => CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput)
  update?: InstanceType<
    typeof CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput
  >;
}

@InputType()
export class CategoryMetadataUpdateToOneWithWhereWithoutCategoryInput {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => CategoryMetadataUpdateWithoutCategoryInput, { nullable: false })
  @Type(() => CategoryMetadataUpdateWithoutCategoryInput)
  data!: InstanceType<typeof CategoryMetadataUpdateWithoutCategoryInput>;
}

@InputType()
export class CategoryMetadataUpdateWithoutCategoryInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataUpdatemetadataInput>;
}

@InputType()
export class CategoryMetadataUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => CategoryMetadataUpdatemetadataInput, { nullable: true })
  metadata?: InstanceType<typeof CategoryMetadataUpdatemetadataInput>;
  @Field(() => CategoryUpdateOneRequiredWithoutMetadataNestedInput, {
    nullable: true,
  })
  category?: InstanceType<
    typeof CategoryUpdateOneRequiredWithoutMetadataNestedInput
  >;
}

@InputType()
export class CategoryMetadataUpdatemetadataInput {
  @Field(() => [GraphQLJSON], { nullable: true })
  set?: Array<any>;
  @Field(() => [GraphQLJSON], { nullable: true })
  push?: Array<any>;
}

@InputType()
export class CategoryMetadataUpsertWithoutCategoryInput {
  @Field(() => CategoryMetadataUpdateWithoutCategoryInput, { nullable: false })
  @Type(() => CategoryMetadataUpdateWithoutCategoryInput)
  update!: InstanceType<typeof CategoryMetadataUpdateWithoutCategoryInput>;
  @Field(() => CategoryMetadataCreateWithoutCategoryInput, { nullable: false })
  @Type(() => CategoryMetadataCreateWithoutCategoryInput)
  create!: InstanceType<typeof CategoryMetadataCreateWithoutCategoryInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
}

@InputType()
export class CategoryMetadataWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => Int, { nullable: true })
  categoryId!: number;
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  AND?: Array<CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  OR?: Array<CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  NOT?: Array<CategoryMetadataWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => JsonListFilter, { nullable: true })
  metadata?: InstanceType<typeof JsonListFilter>;
  @Field(() => CategoryRelationFilter, { nullable: true })
  category?: InstanceType<typeof CategoryRelationFilter>;
}

@InputType()
export class CategoryMetadataWhereInput {
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  AND?: Array<CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  OR?: Array<CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataWhereInput], { nullable: true })
  NOT?: Array<CategoryMetadataWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => IntFilter, { nullable: true })
  categoryId?: InstanceType<typeof IntFilter>;
  @Field(() => JsonListFilter, { nullable: true })
  metadata?: InstanceType<typeof JsonListFilter>;
  @Field(() => CategoryRelationFilter, { nullable: true })
  category?: InstanceType<typeof CategoryRelationFilter>;
}

@ObjectType()
export class CategoryMetadata {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  @Field(() => Int, { nullable: false, description: '' })
  categoryId!: number;
  @Field(() => [GraphQLJSON], { nullable: true, description: '' })
  metadata!: Array<any>;
  /**
   * One to one relation with Category
   */
  @Field(() => Category, {
    nullable: false,
    description: 'One to one relation with Category',
  })
  category?: InstanceType<typeof Category>;
}

@ArgsType()
export class CreateManyCategoryMetadataArgs {
  @Field(() => [CategoryMetadataCreateManyInput], { nullable: false })
  @Type(() => CategoryMetadataCreateManyInput)
  data!: Array<CategoryMetadataCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneCategoryMetadataArgs {
  @Field(() => CategoryMetadataCreateInput, { nullable: false })
  @Type(() => CategoryMetadataCreateInput)
  data!: InstanceType<typeof CategoryMetadataCreateInput>;
}

@ArgsType()
export class DeleteManyCategoryMetadataArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
}

@ArgsType()
export class DeleteOneCategoryMetadataArgs {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  @Type(() => CategoryMetadataWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryMetadataWhereUniqueInput, 'id' | 'categoryId'>;
}

@ArgsType()
export class FindFirstCategoryMetadataOrThrowArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryMetadataOrderByWithRelationInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof CategoryMetadataScalarFieldEnum>;
}

@ArgsType()
export class FindFirstCategoryMetadataArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryMetadataOrderByWithRelationInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof CategoryMetadataScalarFieldEnum>;
}

@ArgsType()
export class FindManyCategoryMetadataArgs {
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
  @Field(() => [CategoryMetadataOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<CategoryMetadataOrderByWithRelationInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<
    CategoryMetadataWhereUniqueInput,
    'id' | 'categoryId'
  >;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [CategoryMetadataScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof CategoryMetadataScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueCategoryMetadataOrThrowArgs {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  @Type(() => CategoryMetadataWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryMetadataWhereUniqueInput, 'id' | 'categoryId'>;
}

@ArgsType()
export class FindUniqueCategoryMetadataArgs {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  @Type(() => CategoryMetadataWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryMetadataWhereUniqueInput, 'id' | 'categoryId'>;
}

@ArgsType()
export class UpdateManyCategoryMetadataArgs {
  @Field(() => CategoryMetadataUpdateManyMutationInput, { nullable: false })
  @Type(() => CategoryMetadataUpdateManyMutationInput)
  data!: InstanceType<typeof CategoryMetadataUpdateManyMutationInput>;
  @Field(() => CategoryMetadataWhereInput, { nullable: true })
  @Type(() => CategoryMetadataWhereInput)
  where?: InstanceType<typeof CategoryMetadataWhereInput>;
}

@ArgsType()
export class UpdateOneCategoryMetadataArgs {
  @Field(() => CategoryMetadataUpdateInput, { nullable: false })
  @Type(() => CategoryMetadataUpdateInput)
  data!: InstanceType<typeof CategoryMetadataUpdateInput>;
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  @Type(() => CategoryMetadataWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryMetadataWhereUniqueInput, 'id' | 'categoryId'>;
}

@ArgsType()
export class UpsertOneCategoryMetadataArgs {
  @Field(() => CategoryMetadataWhereUniqueInput, { nullable: false })
  @Type(() => CategoryMetadataWhereUniqueInput)
  where!: Prisma.AtLeast<CategoryMetadataWhereUniqueInput, 'id' | 'categoryId'>;
  @Field(() => CategoryMetadataCreateInput, { nullable: false })
  @Type(() => CategoryMetadataCreateInput)
  create!: InstanceType<typeof CategoryMetadataCreateInput>;
  @Field(() => CategoryMetadataUpdateInput, { nullable: false })
  @Type(() => CategoryMetadataUpdateInput)
  update!: InstanceType<typeof CategoryMetadataUpdateInput>;
}

@ObjectType()
export class AggregateHiddenModel {
  @Field(() => HiddenModelCountAggregate, { nullable: true })
  _count?: InstanceType<typeof HiddenModelCountAggregate>;
  @Field(() => HiddenModelAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof HiddenModelAvgAggregate>;
  @Field(() => HiddenModelSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof HiddenModelSumAggregate>;
  @Field(() => HiddenModelMinAggregate, { nullable: true })
  _min?: InstanceType<typeof HiddenModelMinAggregate>;
  @Field(() => HiddenModelMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof HiddenModelMaxAggregate>;
}

@ArgsType()
export class CreateManyHiddenModelArgs {
  @Field(() => [HiddenModelCreateManyInput], { nullable: false })
  @Type(() => HiddenModelCreateManyInput)
  data!: Array<HiddenModelCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneHiddenModelArgs {
  @Field(() => HiddenModelCreateInput, { nullable: false })
  @Type(() => HiddenModelCreateInput)
  data!: InstanceType<typeof HiddenModelCreateInput>;
}

@ArgsType()
export class DeleteManyHiddenModelArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
}

@ArgsType()
export class DeleteOneHiddenModelArgs {
  @Field(() => HiddenModelWhereUniqueInput, { nullable: false })
  @Type(() => HiddenModelWhereUniqueInput)
  where!: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstHiddenModelOrThrowArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<HiddenModelOrderByWithRelationInput>;
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof HiddenModelScalarFieldEnum>;
}

@ArgsType()
export class FindFirstHiddenModelArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<HiddenModelOrderByWithRelationInput>;
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof HiddenModelScalarFieldEnum>;
}

@ArgsType()
export class FindManyHiddenModelArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<HiddenModelOrderByWithRelationInput>;
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof HiddenModelScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueHiddenModelOrThrowArgs {
  @Field(() => HiddenModelWhereUniqueInput, { nullable: false })
  @Type(() => HiddenModelWhereUniqueInput)
  where!: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueHiddenModelArgs {
  @Field(() => HiddenModelWhereUniqueInput, { nullable: false })
  @Type(() => HiddenModelWhereUniqueInput)
  where!: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class HiddenModelAggregateArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
  @Field(() => [HiddenModelOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<HiddenModelOrderByWithRelationInput>;
  @Field(() => HiddenModelWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => HiddenModelCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof HiddenModelCountAggregateInput>;
  @Field(() => HiddenModelAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof HiddenModelAvgAggregateInput>;
  @Field(() => HiddenModelSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof HiddenModelSumAggregateInput>;
  @Field(() => HiddenModelMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof HiddenModelMinAggregateInput>;
  @Field(() => HiddenModelMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof HiddenModelMaxAggregateInput>;
}

@InputType()
export class HiddenModelAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
}

@ObjectType()
export class HiddenModelAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
}

@InputType()
export class HiddenModelAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
}

@InputType()
export class HiddenModelCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  data?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class HiddenModelCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  data!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class HiddenModelCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  data?: keyof typeof SortOrder;
}

@InputType()
export class HiddenModelCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => GraphQLJSON, { nullable: false })
  data!: any;
}

@InputType()
export class HiddenModelCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => GraphQLJSON, { nullable: false })
  data!: any;
}

@ArgsType()
export class HiddenModelGroupByArgs {
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
  @Field(() => [HiddenModelOrderByWithAggregationInput], { nullable: true })
  orderBy?: Array<HiddenModelOrderByWithAggregationInput>;
  @Field(() => [HiddenModelScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof HiddenModelScalarFieldEnum>;
  @Field(() => HiddenModelScalarWhereWithAggregatesInput, { nullable: true })
  having?: InstanceType<typeof HiddenModelScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => HiddenModelCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof HiddenModelCountAggregateInput>;
  @Field(() => HiddenModelAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof HiddenModelAvgAggregateInput>;
  @Field(() => HiddenModelSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof HiddenModelSumAggregateInput>;
  @Field(() => HiddenModelMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof HiddenModelMinAggregateInput>;
  @Field(() => HiddenModelMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof HiddenModelMaxAggregateInput>;
}

@ObjectType()
export class HiddenModelGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => GraphQLJSON, { nullable: false })
  data!: any;
  @Field(() => HiddenModelCountAggregate, { nullable: true })
  _count?: InstanceType<typeof HiddenModelCountAggregate>;
  @Field(() => HiddenModelAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof HiddenModelAvgAggregate>;
  @Field(() => HiddenModelSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof HiddenModelSumAggregate>;
  @Field(() => HiddenModelMinAggregate, { nullable: true })
  _min?: InstanceType<typeof HiddenModelMinAggregate>;
  @Field(() => HiddenModelMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof HiddenModelMaxAggregate>;
}

@InputType()
export class HiddenModelMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
}

@ObjectType()
export class HiddenModelMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
}

@InputType()
export class HiddenModelMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class HiddenModelMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
}

@ObjectType()
export class HiddenModelMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
}

@InputType()
export class HiddenModelMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
}

@InputType()
export class HiddenModelOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  data?: keyof typeof SortOrder;
  @Field(() => HiddenModelCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof HiddenModelCountOrderByAggregateInput>;
  @Field(() => HiddenModelAvgOrderByAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof HiddenModelAvgOrderByAggregateInput>;
  @Field(() => HiddenModelMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof HiddenModelMaxOrderByAggregateInput>;
  @Field(() => HiddenModelMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof HiddenModelMinOrderByAggregateInput>;
  @Field(() => HiddenModelSumOrderByAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof HiddenModelSumOrderByAggregateInput>;
}

@InputType()
export class HiddenModelOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  data?: keyof typeof SortOrder;
}

@InputType()
export class HiddenModelScalarWhereWithAggregatesInput {
  @Field(() => [HiddenModelScalarWhereWithAggregatesInput], { nullable: true })
  AND?: Array<HiddenModelScalarWhereWithAggregatesInput>;
  @Field(() => [HiddenModelScalarWhereWithAggregatesInput], { nullable: true })
  OR?: Array<HiddenModelScalarWhereWithAggregatesInput>;
  @Field(() => [HiddenModelScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: Array<HiddenModelScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => JsonWithAggregatesFilter, { nullable: true })
  @Type(() => JsonWithAggregatesFilter)
  data?: InstanceType<typeof JsonWithAggregatesFilter>;
}

@InputType()
export class HiddenModelSumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
}

@ObjectType()
export class HiddenModelSumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
}

@InputType()
export class HiddenModelSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
}

@InputType()
export class HiddenModelUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => GraphQLJSON, { nullable: false })
  data!: any;
}

@InputType()
export class HiddenModelUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  data?: any;
}

@InputType()
export class HiddenModelUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  data?: any;
}

@InputType()
export class HiddenModelUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  data?: any;
}

@InputType()
export class HiddenModelUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  data?: any;
}

@InputType()
export class HiddenModelWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  AND?: Array<HiddenModelWhereInput>;
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  OR?: Array<HiddenModelWhereInput>;
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  NOT?: Array<HiddenModelWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => JsonFilter, { nullable: true })
  @Type(() => JsonFilter)
  data?: InstanceType<typeof JsonFilter>;
}

@InputType()
export class HiddenModelWhereInput {
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  AND?: Array<HiddenModelWhereInput>;
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  OR?: Array<HiddenModelWhereInput>;
  @Field(() => [HiddenModelWhereInput], { nullable: true })
  NOT?: Array<HiddenModelWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => JsonFilter, { nullable: true })
  @Type(() => JsonFilter)
  data?: InstanceType<typeof JsonFilter>;
}

/**
 * @
 * @graphql .hideOperations([GQL_OP_ALL])
 */
@ObjectType({ description: '@@graphql.hideOperations([GQL_OP_ALL])' })
export class HiddenModel {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  @Field(() => GraphQLJSON, { nullable: false, description: '' })
  data!: any;
}

@ArgsType()
export class UpdateManyHiddenModelArgs {
  @Field(() => HiddenModelUpdateManyMutationInput, { nullable: false })
  @Type(() => HiddenModelUpdateManyMutationInput)
  data!: InstanceType<typeof HiddenModelUpdateManyMutationInput>;
  @Field(() => HiddenModelWhereInput, { nullable: true })
  @Type(() => HiddenModelWhereInput)
  where?: InstanceType<typeof HiddenModelWhereInput>;
}

@ArgsType()
export class UpdateOneHiddenModelArgs {
  @Field(() => HiddenModelUpdateInput, { nullable: false })
  @Type(() => HiddenModelUpdateInput)
  data!: InstanceType<typeof HiddenModelUpdateInput>;
  @Field(() => HiddenModelWhereUniqueInput, { nullable: false })
  @Type(() => HiddenModelWhereUniqueInput)
  where!: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneHiddenModelArgs {
  @Field(() => HiddenModelWhereUniqueInput, { nullable: false })
  @Type(() => HiddenModelWhereUniqueInput)
  where!: Prisma.AtLeast<HiddenModelWhereUniqueInput, 'id'>;
  @Field(() => HiddenModelCreateInput, { nullable: false })
  @Type(() => HiddenModelCreateInput)
  create!: InstanceType<typeof HiddenModelCreateInput>;
  @Field(() => HiddenModelUpdateInput, { nullable: false })
  @Type(() => HiddenModelUpdateInput)
  update!: InstanceType<typeof HiddenModelUpdateInput>;
}

@ObjectType()
export class AggregateMiscModel {
  @Field(() => MiscModelCountAggregate, { nullable: true })
  _count?: InstanceType<typeof MiscModelCountAggregate>;
  @Field(() => MiscModelAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof MiscModelAvgAggregate>;
  @Field(() => MiscModelSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof MiscModelSumAggregate>;
  @Field(() => MiscModelMinAggregate, { nullable: true })
  _min?: InstanceType<typeof MiscModelMinAggregate>;
  @Field(() => MiscModelMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof MiscModelMaxAggregate>;
}

@ArgsType()
export class CreateManyMiscModelArgs {
  @Field(() => [MiscModelCreateManyInput], { nullable: false })
  @Type(() => MiscModelCreateManyInput)
  data!: Array<MiscModelCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneMiscModelArgs {
  @Field(() => MiscModelCreateInput, { nullable: false })
  @Type(() => MiscModelCreateInput)
  data!: InstanceType<typeof MiscModelCreateInput>;
}

@ArgsType()
export class DeleteManyMiscModelArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
}

@ArgsType()
export class DeleteOneMiscModelArgs {
  @Field(() => MiscModelWhereUniqueInput, { nullable: false })
  @Type(() => MiscModelWhereUniqueInput)
  where!: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstMiscModelOrThrowArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  @Type(() => MiscModelOrderByWithRelationInput)
  orderBy?: Array<MiscModelOrderByWithRelationInput>;
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  @Type(() => MiscModelWhereUniqueInput)
  cursor?: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof MiscModelScalarFieldEnum>;
}

@ArgsType()
export class FindFirstMiscModelArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  @Type(() => MiscModelOrderByWithRelationInput)
  orderBy?: Array<MiscModelOrderByWithRelationInput>;
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  @Type(() => MiscModelWhereUniqueInput)
  cursor?: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof MiscModelScalarFieldEnum>;
}

@ArgsType()
export class FindManyMiscModelArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  @Type(() => MiscModelOrderByWithRelationInput)
  orderBy?: Array<MiscModelOrderByWithRelationInput>;
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  @Type(() => MiscModelWhereUniqueInput)
  cursor?: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof MiscModelScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueMiscModelOrThrowArgs {
  @Field(() => MiscModelWhereUniqueInput, { nullable: false })
  @Type(() => MiscModelWhereUniqueInput)
  where!: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniqueMiscModelArgs {
  @Field(() => MiscModelWhereUniqueInput, { nullable: false })
  @Type(() => MiscModelWhereUniqueInput)
  where!: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class MiscModelAggregateArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
  @Field(() => [MiscModelOrderByWithRelationInput], { nullable: true })
  @Type(() => MiscModelOrderByWithRelationInput)
  orderBy?: Array<MiscModelOrderByWithRelationInput>;
  @Field(() => MiscModelWhereUniqueInput, { nullable: true })
  @Type(() => MiscModelWhereUniqueInput)
  cursor?: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => MiscModelCountAggregateInput, { nullable: true })
  @Type(() => MiscModelCountAggregateInput)
  _count?: InstanceType<typeof MiscModelCountAggregateInput>;
  @Field(() => MiscModelAvgAggregateInput, { nullable: true })
  @Type(() => MiscModelAvgAggregateInput)
  _avg?: InstanceType<typeof MiscModelAvgAggregateInput>;
  @Field(() => MiscModelSumAggregateInput, { nullable: true })
  @Type(() => MiscModelSumAggregateInput)
  _sum?: InstanceType<typeof MiscModelSumAggregateInput>;
  @Field(() => MiscModelMinAggregateInput, { nullable: true })
  @Type(() => MiscModelMinAggregateInput)
  _min?: InstanceType<typeof MiscModelMinAggregateInput>;
  @Field(() => MiscModelMaxAggregateInput, { nullable: true })
  @Type(() => MiscModelMaxAggregateInput)
  _max?: InstanceType<typeof MiscModelMaxAggregateInput>;
}

@InputType()
export class MiscModelAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  decimalField?: true;
  @Field(() => Boolean, { nullable: true })
  decimalList?: true;
  @Field(() => Boolean, { nullable: true })
  floatField?: true;
  @HideField()
  bigIntField?: true;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: true;
}

@ObjectType()
export class MiscModelAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
  @Field(() => GraphQLDecimal, { nullable: true })
  decimalField?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  decimalList?: Decimal;
  @HideField()
  floatField?: number;
  @HideField()
  bigIntField?: number;
  @Field(() => Float, { nullable: true })
  bigIntList?: number;
}

@InputType()
export class MiscModelAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: keyof typeof SortOrder;
}

@InputType()
export class MiscModelCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  jsonField?: true;
  @Field(() => Boolean, { nullable: true })
  jsonList?: true;
  @Field(() => Boolean, { nullable: true })
  stringList?: true;
  @Field(() => Boolean, { nullable: true })
  decimalField?: true;
  @Field(() => Boolean, { nullable: true })
  decimalList?: true;
  @Field(() => Boolean, { nullable: true })
  floatField?: true;
  @Field(() => Boolean, { nullable: true })
  bytesField?: true;
  @Field(() => Boolean, { nullable: true })
  bytesList?: true;
  @HideField()
  bigIntField?: true;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: true;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: true;
  @HideField()
  dateTimeList?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class MiscModelCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  name!: number;
  @Field(() => Int, { nullable: false })
  jsonField!: number;
  @Field(() => Int, { nullable: false })
  jsonList!: number;
  @Field(() => Int, { nullable: false })
  stringList!: number;
  @Field(() => Int, { nullable: false })
  decimalField!: number;
  @Field(() => Int, { nullable: false })
  decimalList!: number;
  @HideField()
  floatField!: number;
  @HideField()
  bytesField!: number;
  @Field(() => Int, { nullable: false })
  bytesList!: number;
  @HideField()
  bigIntField!: number;
  @Field(() => Int, { nullable: false })
  bigIntList!: number;
  @Field(() => Int, { nullable: false })
  dateTimeField!: number;
  @Field(() => Int, { nullable: false })
  dateTimeList!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class MiscModelCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  stringList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesList?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: keyof typeof SortOrder;
  @HideField()
  dateTimeList?: keyof typeof SortOrder;
}

@InputType()
export class MiscModelCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField!: any;
  @Field(() => MiscModelCreatejsonListInput, { nullable: true })
  @Type(() => MiscModelCreatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelCreatejsonListInput>;
  @Field(() => MiscModelCreatestringListInput, { nullable: true })
  @Type(() => MiscModelCreatestringListInput)
  stringList?: InstanceType<typeof MiscModelCreatestringListInput>;
  @Field(() => GraphQLDecimal, { nullable: false })
  @Type(() => Object)
  @Transform(transformToDecimal)
  decimalField!: Decimal;
  @Field(() => MiscModelCreatedecimalListInput, { nullable: true })
  @Type(() => MiscModelCreatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelCreatedecimalListInput>;
  @Field(() => Float, { nullable: false })
  floatField!: number;
  @Field(() => String, { nullable: false })
  bytesField!: Buffer;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelCreatebytesListInput>;
  @HideField()
  bigIntField!: bigint | number;
  @Field(() => MiscModelCreatebigIntListInput, { nullable: true })
  @Type(() => MiscModelCreatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelCreatebigIntListInput>;
  @Field(() => Date, { nullable: false })
  dateTimeField!: Date | string;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelCreatedateTimeListInput>;
}

@InputType()
export class MiscModelCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField!: any;
  @Field(() => MiscModelCreatejsonListInput, { nullable: true })
  @Type(() => MiscModelCreatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelCreatejsonListInput>;
  @Field(() => MiscModelCreatestringListInput, { nullable: true })
  @Type(() => MiscModelCreatestringListInput)
  stringList?: InstanceType<typeof MiscModelCreatestringListInput>;
  @Field(() => GraphQLDecimal, { nullable: false })
  @Type(() => Object)
  @Transform(transformToDecimal)
  decimalField!: Decimal;
  @Field(() => MiscModelCreatedecimalListInput, { nullable: true })
  @Type(() => MiscModelCreatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelCreatedecimalListInput>;
  @Field(() => Float, { nullable: false })
  floatField!: number;
  @Field(() => String, { nullable: false })
  bytesField!: Buffer;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelCreatebytesListInput>;
  @HideField()
  bigIntField!: bigint | number;
  @Field(() => MiscModelCreatebigIntListInput, { nullable: true })
  @Type(() => MiscModelCreatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelCreatebigIntListInput>;
  @Field(() => Date, { nullable: false })
  dateTimeField!: Date | string;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelCreatedateTimeListInput>;
}

@InputType()
export class MiscModelCreatebigIntListInput {
  @Field(() => [GraphQLBigInt], { nullable: false })
  set!: Array<bigint> | Array<number>;
}

@InputType()
export class MiscModelCreatebytesListInput {
  @Field(() => [String], { nullable: false })
  set!: Array<Buffer>;
}

@InputType()
export class MiscModelCreatedateTimeListInput {
  @Field(() => [Date], { nullable: false })
  set!: Array<Date> | Array<string>;
}

@InputType()
export class MiscModelCreatedecimalListInput {
  @Field(() => [GraphQLDecimal], { nullable: false })
  @Type(() => Object)
  @Transform(transformToDecimal)
  set!: Array<Decimal>;
}

@InputType()
export class MiscModelCreatejsonListInput {
  @Field(() => [GraphQLJSON], { nullable: false })
  set!: Array<any>;
}

@InputType()
export class MiscModelCreatestringListInput {
  @Field(() => [String], { nullable: false })
  set!: Array<string>;
}

@ArgsType()
export class MiscModelGroupByArgs {
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
  @Field(() => [MiscModelOrderByWithAggregationInput], { nullable: true })
  @Type(() => MiscModelOrderByWithAggregationInput)
  orderBy?: Array<MiscModelOrderByWithAggregationInput>;
  @Field(() => [MiscModelScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof MiscModelScalarFieldEnum>;
  @Field(() => MiscModelScalarWhereWithAggregatesInput, { nullable: true })
  @Type(() => MiscModelScalarWhereWithAggregatesInput)
  having?: InstanceType<typeof MiscModelScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => MiscModelCountAggregateInput, { nullable: true })
  @Type(() => MiscModelCountAggregateInput)
  _count?: InstanceType<typeof MiscModelCountAggregateInput>;
  @Field(() => MiscModelAvgAggregateInput, { nullable: true })
  @Type(() => MiscModelAvgAggregateInput)
  _avg?: InstanceType<typeof MiscModelAvgAggregateInput>;
  @Field(() => MiscModelSumAggregateInput, { nullable: true })
  @Type(() => MiscModelSumAggregateInput)
  _sum?: InstanceType<typeof MiscModelSumAggregateInput>;
  @Field(() => MiscModelMinAggregateInput, { nullable: true })
  @Type(() => MiscModelMinAggregateInput)
  _min?: InstanceType<typeof MiscModelMinAggregateInput>;
  @Field(() => MiscModelMaxAggregateInput, { nullable: true })
  @Type(() => MiscModelMaxAggregateInput)
  _max?: InstanceType<typeof MiscModelMaxAggregateInput>;
}

@ObjectType()
export class MiscModelGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField!: any;
  @Field(() => [GraphQLJSON], { nullable: true })
  jsonList?: Array<any>;
  @Field(() => [String], { nullable: true })
  stringList?: Array<string>;
  @Field(() => GraphQLDecimal, { nullable: false })
  decimalField!: Decimal;
  @Field(() => [GraphQLDecimal], { nullable: true })
  decimalList?: Array<Decimal>;
  @HideField()
  floatField!: number;
  @HideField()
  bytesField!: Buffer;
  @Field(() => [String], { nullable: true })
  bytesList?: Array<Buffer>;
  @HideField()
  bigIntField!: bigint | number;
  @Field(() => [GraphQLBigInt], { nullable: true })
  bigIntList?: Array<bigint> | Array<number>;
  @Field(() => Date, { nullable: false })
  dateTimeField!: Date | string;
  @Field(() => [Date], { nullable: true })
  dateTimeList?: Array<Date> | Array<string>;
  @Field(() => MiscModelCountAggregate, { nullable: true })
  _count?: InstanceType<typeof MiscModelCountAggregate>;
  @Field(() => MiscModelAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof MiscModelAvgAggregate>;
  @Field(() => MiscModelSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof MiscModelSumAggregate>;
  @Field(() => MiscModelMinAggregate, { nullable: true })
  _min?: InstanceType<typeof MiscModelMinAggregate>;
  @Field(() => MiscModelMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof MiscModelMaxAggregate>;
}

@InputType()
export class MiscModelMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  decimalField?: true;
  @Field(() => Boolean, { nullable: true })
  floatField?: true;
  @Field(() => Boolean, { nullable: true })
  bytesField?: true;
  @HideField()
  bigIntField?: true;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: true;
}

@ObjectType()
export class MiscModelMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => GraphQLDecimal, { nullable: true })
  decimalField?: Decimal;
  @HideField()
  floatField?: number;
  @HideField()
  bytesField?: Buffer;
  @HideField()
  bigIntField?: bigint | number;
  @Field(() => Date, { nullable: true })
  dateTimeField?: Date | string;
}

@InputType()
export class MiscModelMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: keyof typeof SortOrder;
}

@InputType()
export class MiscModelMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  decimalField?: true;
  @Field(() => Boolean, { nullable: true })
  floatField?: true;
  @Field(() => Boolean, { nullable: true })
  bytesField?: true;
  @HideField()
  bigIntField?: true;
  @Field(() => Boolean, { nullable: true })
  dateTimeField?: true;
}

@ObjectType()
export class MiscModelMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => GraphQLDecimal, { nullable: true })
  decimalField?: Decimal;
  @HideField()
  floatField?: number;
  @HideField()
  bytesField?: Buffer;
  @HideField()
  bigIntField?: bigint | number;
  @Field(() => Date, { nullable: true })
  dateTimeField?: Date | string;
}

@InputType()
export class MiscModelMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: keyof typeof SortOrder;
}

@InputType()
export class MiscModelOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  stringList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesList?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: keyof typeof SortOrder;
  @HideField()
  dateTimeList?: keyof typeof SortOrder;
  @Field(() => MiscModelCountOrderByAggregateInput, { nullable: true })
  @Type(() => MiscModelCountOrderByAggregateInput)
  _count?: InstanceType<typeof MiscModelCountOrderByAggregateInput>;
  @Field(() => MiscModelAvgOrderByAggregateInput, { nullable: true })
  @Type(() => MiscModelAvgOrderByAggregateInput)
  _avg?: InstanceType<typeof MiscModelAvgOrderByAggregateInput>;
  @Field(() => MiscModelMaxOrderByAggregateInput, { nullable: true })
  @Type(() => MiscModelMaxOrderByAggregateInput)
  _max?: InstanceType<typeof MiscModelMaxOrderByAggregateInput>;
  @Field(() => MiscModelMinOrderByAggregateInput, { nullable: true })
  @Type(() => MiscModelMinOrderByAggregateInput)
  _min?: InstanceType<typeof MiscModelMinOrderByAggregateInput>;
  @Field(() => MiscModelSumOrderByAggregateInput, { nullable: true })
  @Type(() => MiscModelSumOrderByAggregateInput)
  _sum?: InstanceType<typeof MiscModelSumOrderByAggregateInput>;
}

@InputType()
export class MiscModelOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  jsonList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  stringList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bytesList?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  dateTimeField?: keyof typeof SortOrder;
  @HideField()
  dateTimeList?: keyof typeof SortOrder;
}

@InputType()
export class MiscModelScalarWhereWithAggregatesInput {
  @Field(() => [MiscModelScalarWhereWithAggregatesInput], { nullable: true })
  @Type(() => MiscModelScalarWhereWithAggregatesInput)
  AND?: Array<MiscModelScalarWhereWithAggregatesInput>;
  @Field(() => [MiscModelScalarWhereWithAggregatesInput], { nullable: true })
  @Type(() => MiscModelScalarWhereWithAggregatesInput)
  OR?: Array<MiscModelScalarWhereWithAggregatesInput>;
  @Field(() => [MiscModelScalarWhereWithAggregatesInput], { nullable: true })
  @Type(() => MiscModelScalarWhereWithAggregatesInput)
  NOT?: Array<MiscModelScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  name?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => JsonWithAggregatesFilter, { nullable: true })
  jsonField?: InstanceType<typeof JsonWithAggregatesFilter>;
  @Field(() => JsonListFilter, { nullable: true })
  jsonList?: InstanceType<typeof JsonListFilter>;
  @Field(() => StringListFilter, { nullable: true })
  stringList?: InstanceType<typeof StringListFilter>;
  @Field(() => DecimalWithAggregatesFilter, { nullable: true })
  @Type(() => DecimalWithAggregatesFilter)
  decimalField?: InstanceType<typeof DecimalWithAggregatesFilter>;
  @Field(() => DecimalListFilter, { nullable: true })
  @Type(() => DecimalListFilter)
  decimalList?: InstanceType<typeof DecimalListFilter>;
  @Field(() => FloatWithAggregatesFilter, { nullable: true })
  floatField?: InstanceType<typeof FloatWithAggregatesFilter>;
  @Field(() => BytesWithAggregatesFilter, { nullable: true })
  bytesField?: InstanceType<typeof BytesWithAggregatesFilter>;
  @Field(() => BytesListFilter, { nullable: true })
  bytesList?: InstanceType<typeof BytesListFilter>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntWithAggregatesFilter>;
  @Field(() => BigIntListFilter, { nullable: true })
  bigIntList?: InstanceType<typeof BigIntListFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @HideField()
  dateTimeList?: InstanceType<typeof DateTimeListFilter>;
}

@InputType()
export class MiscModelSumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  decimalField?: true;
  @Field(() => Boolean, { nullable: true })
  decimalList?: true;
  @Field(() => Boolean, { nullable: true })
  floatField?: true;
  @HideField()
  bigIntField?: true;
  @Field(() => Boolean, { nullable: true })
  bigIntList?: true;
}

@ObjectType()
export class MiscModelSumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => GraphQLDecimal, { nullable: true })
  decimalField?: Decimal;
  @Field(() => [GraphQLDecimal], { nullable: true })
  decimalList?: Array<Decimal>;
  @HideField()
  floatField?: number;
  @HideField()
  bigIntField?: bigint | number;
  @Field(() => [GraphQLBigInt], { nullable: true })
  bigIntList?: Array<bigint> | Array<number>;
}

@InputType()
export class MiscModelSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  decimalList?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  floatField?: keyof typeof SortOrder;
  @HideField()
  bigIntField?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bigIntList?: keyof typeof SortOrder;
}

@InputType()
export class MiscModelUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  name!: string;
  @Field(() => GraphQLJSON, { nullable: false })
  jsonField!: any;
  @Field(() => MiscModelCreatejsonListInput, { nullable: true })
  @Type(() => MiscModelCreatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelCreatejsonListInput>;
  @Field(() => MiscModelCreatestringListInput, { nullable: true })
  @Type(() => MiscModelCreatestringListInput)
  stringList?: InstanceType<typeof MiscModelCreatestringListInput>;
  @Field(() => GraphQLDecimal, { nullable: false })
  @Type(() => Object)
  @Transform(transformToDecimal)
  decimalField!: Decimal;
  @Field(() => MiscModelCreatedecimalListInput, { nullable: true })
  @Type(() => MiscModelCreatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelCreatedecimalListInput>;
  @Field(() => Float, { nullable: false })
  floatField!: number;
  @Field(() => String, { nullable: false })
  bytesField!: Buffer;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelCreatebytesListInput>;
  @HideField()
  bigIntField!: bigint | number;
  @Field(() => MiscModelCreatebigIntListInput, { nullable: true })
  @Type(() => MiscModelCreatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelCreatebigIntListInput>;
  @Field(() => Date, { nullable: false })
  dateTimeField!: Date | string;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelCreatedateTimeListInput>;
}

@InputType()
export class MiscModelUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  jsonField?: any;
  @Field(() => MiscModelUpdatejsonListInput, { nullable: true })
  @Type(() => MiscModelUpdatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelUpdatejsonListInput>;
  @Field(() => MiscModelUpdatestringListInput, { nullable: true })
  @Type(() => MiscModelUpdatestringListInput)
  stringList?: InstanceType<typeof MiscModelUpdatestringListInput>;
  @Field(() => DecimalFieldUpdateOperationsInput, { nullable: true })
  @Type(() => DecimalFieldUpdateOperationsInput)
  decimalField?: InstanceType<typeof DecimalFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatedecimalListInput, { nullable: true })
  @Type(() => MiscModelUpdatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelUpdatedecimalListInput>;
  @Field(() => FloatFieldUpdateOperationsInput, { nullable: true })
  floatField?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
  @Field(() => BytesFieldUpdateOperationsInput, { nullable: true })
  bytesField?: InstanceType<typeof BytesFieldUpdateOperationsInput>;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelUpdatebytesListInput>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatebigIntListInput, { nullable: true })
  @Type(() => MiscModelUpdatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelUpdatebigIntListInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelUpdatedateTimeListInput>;
}

@InputType()
export class MiscModelUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  jsonField?: any;
  @Field(() => MiscModelUpdatejsonListInput, { nullable: true })
  @Type(() => MiscModelUpdatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelUpdatejsonListInput>;
  @Field(() => MiscModelUpdatestringListInput, { nullable: true })
  @Type(() => MiscModelUpdatestringListInput)
  stringList?: InstanceType<typeof MiscModelUpdatestringListInput>;
  @Field(() => DecimalFieldUpdateOperationsInput, { nullable: true })
  @Type(() => DecimalFieldUpdateOperationsInput)
  decimalField?: InstanceType<typeof DecimalFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatedecimalListInput, { nullable: true })
  @Type(() => MiscModelUpdatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelUpdatedecimalListInput>;
  @Field(() => FloatFieldUpdateOperationsInput, { nullable: true })
  floatField?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
  @Field(() => BytesFieldUpdateOperationsInput, { nullable: true })
  bytesField?: InstanceType<typeof BytesFieldUpdateOperationsInput>;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelUpdatebytesListInput>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatebigIntListInput, { nullable: true })
  @Type(() => MiscModelUpdatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelUpdatebigIntListInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelUpdatedateTimeListInput>;
}

@InputType()
export class MiscModelUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  jsonField?: any;
  @Field(() => MiscModelUpdatejsonListInput, { nullable: true })
  @Type(() => MiscModelUpdatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelUpdatejsonListInput>;
  @Field(() => MiscModelUpdatestringListInput, { nullable: true })
  @Type(() => MiscModelUpdatestringListInput)
  stringList?: InstanceType<typeof MiscModelUpdatestringListInput>;
  @Field(() => DecimalFieldUpdateOperationsInput, { nullable: true })
  @Type(() => DecimalFieldUpdateOperationsInput)
  decimalField?: InstanceType<typeof DecimalFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatedecimalListInput, { nullable: true })
  @Type(() => MiscModelUpdatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelUpdatedecimalListInput>;
  @Field(() => FloatFieldUpdateOperationsInput, { nullable: true })
  floatField?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
  @Field(() => BytesFieldUpdateOperationsInput, { nullable: true })
  bytesField?: InstanceType<typeof BytesFieldUpdateOperationsInput>;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelUpdatebytesListInput>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatebigIntListInput, { nullable: true })
  @Type(() => MiscModelUpdatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelUpdatebigIntListInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelUpdatedateTimeListInput>;
}

@InputType()
export class MiscModelUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => GraphQLJSON, { nullable: true })
  jsonField?: any;
  @Field(() => MiscModelUpdatejsonListInput, { nullable: true })
  @Type(() => MiscModelUpdatejsonListInput)
  jsonList?: InstanceType<typeof MiscModelUpdatejsonListInput>;
  @Field(() => MiscModelUpdatestringListInput, { nullable: true })
  @Type(() => MiscModelUpdatestringListInput)
  stringList?: InstanceType<typeof MiscModelUpdatestringListInput>;
  @Field(() => DecimalFieldUpdateOperationsInput, { nullable: true })
  @Type(() => DecimalFieldUpdateOperationsInput)
  decimalField?: InstanceType<typeof DecimalFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatedecimalListInput, { nullable: true })
  @Type(() => MiscModelUpdatedecimalListInput)
  decimalList?: InstanceType<typeof MiscModelUpdatedecimalListInput>;
  @Field(() => FloatFieldUpdateOperationsInput, { nullable: true })
  floatField?: InstanceType<typeof FloatFieldUpdateOperationsInput>;
  @Field(() => BytesFieldUpdateOperationsInput, { nullable: true })
  bytesField?: InstanceType<typeof BytesFieldUpdateOperationsInput>;
  @HideField()
  bytesList?: InstanceType<typeof MiscModelUpdatebytesListInput>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntFieldUpdateOperationsInput>;
  @Field(() => MiscModelUpdatebigIntListInput, { nullable: true })
  @Type(() => MiscModelUpdatebigIntListInput)
  bigIntList?: InstanceType<typeof MiscModelUpdatebigIntListInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  dateTimeList?: InstanceType<typeof MiscModelUpdatedateTimeListInput>;
}

@InputType()
export class MiscModelUpdatebigIntListInput {
  @Field(() => [GraphQLBigInt], { nullable: true })
  set?: Array<bigint> | Array<number>;
  @Field(() => [GraphQLBigInt], { nullable: true })
  push?: Array<bigint> | Array<number>;
}

@InputType()
export class MiscModelUpdatebytesListInput {
  @Field(() => [String], { nullable: true })
  set?: Array<Buffer>;
  @Field(() => [String], { nullable: true })
  push?: Array<Buffer>;
}

@InputType()
export class MiscModelUpdatedateTimeListInput {
  @Field(() => [Date], { nullable: true })
  set?: Array<Date> | Array<string>;
  @Field(() => [Date], { nullable: true })
  push?: Array<Date> | Array<string>;
}

@InputType()
export class MiscModelUpdatedecimalListInput {
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  set?: Array<Decimal>;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  push?: Array<Decimal>;
}

@InputType()
export class MiscModelUpdatejsonListInput {
  @Field(() => [GraphQLJSON], { nullable: true })
  set?: Array<any>;
  @Field(() => [GraphQLJSON], { nullable: true })
  push?: Array<any>;
}

@InputType()
export class MiscModelUpdatestringListInput {
  @Field(() => [String], { nullable: true })
  set?: Array<string>;
  @Field(() => [String], { nullable: true })
  push?: Array<string>;
}

@InputType()
export class MiscModelWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => [MiscModelWhereInput], { nullable: true })
  @Type(() => MiscModelWhereInput)
  AND?: Array<MiscModelWhereInput>;
  @Field(() => [MiscModelWhereInput], { nullable: true })
  @Type(() => MiscModelWhereInput)
  OR?: Array<MiscModelWhereInput>;
  @Field(() => [MiscModelWhereInput], { nullable: true })
  @Type(() => MiscModelWhereInput)
  NOT?: Array<MiscModelWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
  @Field(() => JsonFilter, { nullable: true })
  jsonField?: InstanceType<typeof JsonFilter>;
  @Field(() => JsonListFilter, { nullable: true })
  jsonList?: InstanceType<typeof JsonListFilter>;
  @Field(() => StringListFilter, { nullable: true })
  stringList?: InstanceType<typeof StringListFilter>;
  @Field(() => DecimalFilter, { nullable: true })
  @Type(() => DecimalFilter)
  decimalField?: InstanceType<typeof DecimalFilter>;
  @Field(() => DecimalListFilter, { nullable: true })
  @Type(() => DecimalListFilter)
  decimalList?: InstanceType<typeof DecimalListFilter>;
  @Field(() => FloatFilter, { nullable: true })
  floatField?: InstanceType<typeof FloatFilter>;
  @Field(() => BytesFilter, { nullable: true })
  bytesField?: InstanceType<typeof BytesFilter>;
  @Field(() => BytesListFilter, { nullable: true })
  bytesList?: InstanceType<typeof BytesListFilter>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntFilter>;
  @Field(() => BigIntListFilter, { nullable: true })
  bigIntList?: InstanceType<typeof BigIntListFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeFilter>;
  @HideField()
  dateTimeList?: InstanceType<typeof DateTimeListFilter>;
}

@InputType()
export class MiscModelWhereInput {
  @Field(() => [MiscModelWhereInput], { nullable: true })
  @Type(() => MiscModelWhereInput)
  AND?: Array<MiscModelWhereInput>;
  @Field(() => [MiscModelWhereInput], { nullable: true })
  @Type(() => MiscModelWhereInput)
  OR?: Array<MiscModelWhereInput>;
  @Field(() => [MiscModelWhereInput], { nullable: true })
  @Type(() => MiscModelWhereInput)
  NOT?: Array<MiscModelWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
  @Field(() => JsonFilter, { nullable: true })
  jsonField?: InstanceType<typeof JsonFilter>;
  @Field(() => JsonListFilter, { nullable: true })
  jsonList?: InstanceType<typeof JsonListFilter>;
  @Field(() => StringListFilter, { nullable: true })
  stringList?: InstanceType<typeof StringListFilter>;
  @Field(() => DecimalFilter, { nullable: true })
  @Type(() => DecimalFilter)
  decimalField?: InstanceType<typeof DecimalFilter>;
  @Field(() => DecimalListFilter, { nullable: true })
  @Type(() => DecimalListFilter)
  decimalList?: InstanceType<typeof DecimalListFilter>;
  @Field(() => FloatFilter, { nullable: true })
  floatField?: InstanceType<typeof FloatFilter>;
  @Field(() => BytesFilter, { nullable: true })
  bytesField?: InstanceType<typeof BytesFilter>;
  @Field(() => BytesListFilter, { nullable: true })
  bytesList?: InstanceType<typeof BytesListFilter>;
  @HideField()
  bigIntField?: InstanceType<typeof BigIntFilter>;
  @Field(() => BigIntListFilter, { nullable: true })
  bigIntList?: InstanceType<typeof BigIntListFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  dateTimeField?: InstanceType<typeof DateTimeFilter>;
  @HideField()
  dateTimeList?: InstanceType<typeof DateTimeListFilter>;
}

/**
 * @
 * @graphql .hideOperations([GQL_OP_CREATE, GQL_OP_UPDATE])
 */
@ObjectType({
  description: '@@graphql.hideOperations([GQL_OP_CREATE, GQL_OP_UPDATE])',
})
export class MiscModel {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  @Field(() => String, { nullable: false, description: '' })
  name!: string;
  @Field(() => GraphQLJSON, { nullable: false, description: '' })
  jsonField!: any;
  @Field(() => [GraphQLJSON], { nullable: true, description: '' })
  jsonList!: Array<any>;
  @Field(() => [String], { nullable: true, description: '' })
  stringList!: Array<string>;
  @Field(() => GraphQLDecimal, { nullable: false, description: '' })
  decimalField!: Decimal;
  @Field(() => [GraphQLDecimal], { nullable: true, description: '' })
  decimalList!: Array<Decimal>;
  @HideField()
  floatField!: number;
  @HideField()
  bytesField!: Buffer;
  @Field(() => [String], { nullable: true })
  bytesList!: Array<Buffer>;
  @HideField()
  bigIntField!: bigint;
  @Field(() => [GraphQLBigInt], { nullable: true, description: '' })
  bigIntList!: Array<bigint>;
  @Field(() => Date, { nullable: false, description: '' })
  dateTimeField!: Date;
  @Field(() => [Date], { nullable: true })
  dateTimeList!: Array<Date>;
}

@ArgsType()
export class UpdateManyMiscModelArgs {
  @Field(() => MiscModelUpdateManyMutationInput, { nullable: false })
  @Type(() => MiscModelUpdateManyMutationInput)
  data!: InstanceType<typeof MiscModelUpdateManyMutationInput>;
  @Field(() => MiscModelWhereInput, { nullable: true })
  @Type(() => MiscModelWhereInput)
  where?: InstanceType<typeof MiscModelWhereInput>;
}

@ArgsType()
export class UpdateOneMiscModelArgs {
  @Field(() => MiscModelUpdateInput, { nullable: false })
  @Type(() => MiscModelUpdateInput)
  data!: InstanceType<typeof MiscModelUpdateInput>;
  @Field(() => MiscModelWhereUniqueInput, { nullable: false })
  @Type(() => MiscModelWhereUniqueInput)
  where!: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOneMiscModelArgs {
  @Field(() => MiscModelWhereUniqueInput, { nullable: false })
  @Type(() => MiscModelWhereUniqueInput)
  where!: Prisma.AtLeast<MiscModelWhereUniqueInput, 'id'>;
  @Field(() => MiscModelCreateInput, { nullable: false })
  @Type(() => MiscModelCreateInput)
  create!: InstanceType<typeof MiscModelCreateInput>;
  @Field(() => MiscModelUpdateInput, { nullable: false })
  @Type(() => MiscModelUpdateInput)
  update!: InstanceType<typeof MiscModelUpdateInput>;
}

@ObjectType()
export class AggregatePost {
  @Field(() => PostCountAggregate, { nullable: true })
  _count?: InstanceType<typeof PostCountAggregate>;
  @Field(() => PostAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof PostAvgAggregate>;
  @Field(() => PostSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof PostSumAggregate>;
  @Field(() => PostMinAggregate, { nullable: true })
  _min?: InstanceType<typeof PostMinAggregate>;
  @Field(() => PostMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof PostMaxAggregate>;
}

@ArgsType()
export class CreateManyPostArgs {
  @Field(() => [PostCreateManyInput], { nullable: false })
  @Type(() => PostCreateManyInput)
  data!: Array<PostCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOnePostArgs {
  @Field(() => PostCreateInput, { nullable: false })
  @Type(() => PostCreateInput)
  data!: InstanceType<typeof PostCreateInput>;
}

@ArgsType()
export class DeleteManyPostArgs {
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
}

@ArgsType()
export class DeleteOnePostArgs {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindFirstPostOrThrowArgs {
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<PostOrderByWithRelationInput>;
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [PostScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof PostScalarFieldEnum>;
}

@ArgsType()
export class FindFirstPostArgs {
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<PostOrderByWithRelationInput>;
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [PostScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof PostScalarFieldEnum>;
}

@ArgsType()
export class FindManyPostArgs {
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<PostOrderByWithRelationInput>;
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [PostScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof PostScalarFieldEnum>;
}

@ArgsType()
export class FindUniquePostOrThrowArgs {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
}

@ArgsType()
export class FindUniquePostArgs {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
}

@ArgsType()
export class PostAggregateArgs {
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
  @Field(() => [PostOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<PostOrderByWithRelationInput>;
  @Field(() => PostWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => PostCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof PostCountAggregateInput>;
  @Field(() => PostAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof PostAvgAggregateInput>;
  @Field(() => PostSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof PostSumAggregateInput>;
  @Field(() => PostMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof PostMinAggregateInput>;
  @Field(() => PostMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof PostMaxAggregateInput>;
}

@InputType()
export class PostAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  authorId?: true;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: true;
}

@ObjectType()
export class PostAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
  @Field(() => Float, { nullable: true })
  authorId?: number;
  @Field(() => Float, { nullable: true })
  anotherAuthorId?: number;
}

@InputType()
export class PostAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
}

@InputType()
export class PostCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  title?: true;
  @Field(() => Boolean, { nullable: true })
  content?: true;
  @Field(() => Boolean, { nullable: true })
  published?: true;
  @Field(() => Boolean, { nullable: true })
  authorId?: true;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: true;
  @Field(() => Boolean, { nullable: true })
  postKind?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class PostCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  title!: number;
  @Field(() => Int, { nullable: false })
  content!: number;
  @Field(() => Int, { nullable: false })
  published!: number;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => Int, { nullable: false })
  postKind!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class PostCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: keyof typeof SortOrder;
}

@ObjectType()
export class PostCount {
  @Field(() => Int, { nullable: false })
  categories?: number;
}

@InputType()
export class PostCreateManyAnotherAuthorInputEnvelope {
  @Field(() => [PostCreateManyAnotherAuthorInput], { nullable: false })
  @Type(() => PostCreateManyAnotherAuthorInput)
  data!: Array<PostCreateManyAnotherAuthorInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@InputType()
export class PostCreateManyAnotherAuthorInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
}

@InputType()
export class PostCreateManyAuthorInputEnvelope {
  @Field(() => [PostCreateManyAuthorInput], { nullable: false })
  @Type(() => PostCreateManyAuthorInput)
  data!: Array<PostCreateManyAuthorInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@InputType()
export class PostCreateManyAuthorInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
}

@InputType()
export class PostCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
}

@InputType()
export class PostCreateNestedManyWithoutAnotherAuthorInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAnotherAuthorInput)
  create?: Array<PostCreateWithoutAnotherAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  @Type(() => PostCreateOrConnectWithoutAnotherAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAnotherAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAnotherAuthorInputEnvelope>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
}

@InputType()
export class PostCreateNestedManyWithoutAuthorInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAuthorInput)
  create?: Array<PostCreateWithoutAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAuthorInputEnvelope>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
}

@InputType()
export class PostCreateNestedManyWithoutCategoriesInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateWithoutCategoriesInput)
  create?: Array<PostCreateWithoutCategoriesInput>;
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutCategoriesInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutCategoriesInput>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
}

@InputType()
export class PostCreateOrConnectWithoutAnotherAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostCreateWithoutAnotherAuthorInput, { nullable: false })
  @Type(() => PostCreateWithoutAnotherAuthorInput)
  create!: InstanceType<typeof PostCreateWithoutAnotherAuthorInput>;
}

@InputType()
export class PostCreateOrConnectWithoutAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostCreateWithoutAuthorInput, { nullable: false })
  @Type(() => PostCreateWithoutAuthorInput)
  create!: InstanceType<typeof PostCreateWithoutAuthorInput>;
}

@InputType()
export class PostCreateOrConnectWithoutCategoriesInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostCreateWithoutCategoriesInput, { nullable: false })
  @Type(() => PostCreateWithoutCategoriesInput)
  create!: InstanceType<typeof PostCreateWithoutCategoriesInput>;
}

@InputType()
export class PostCreateWithoutAnotherAuthorInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => UserCreateNestedOneWithoutPostsInput, { nullable: false })
  author!: InstanceType<typeof UserCreateNestedOneWithoutPostsInput>;
  @Field(() => CategoryCreateNestedManyWithoutPostsInput, { nullable: true })
  categories?: InstanceType<typeof CategoryCreateNestedManyWithoutPostsInput>;
}

@InputType()
export class PostCreateWithoutAuthorInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => UserCreateNestedOneWithoutAnotherPostsInput, { nullable: false })
  anotherAuthor!: InstanceType<
    typeof UserCreateNestedOneWithoutAnotherPostsInput
  >;
  @Field(() => CategoryCreateNestedManyWithoutPostsInput, { nullable: true })
  categories?: InstanceType<typeof CategoryCreateNestedManyWithoutPostsInput>;
}

@InputType()
export class PostCreateWithoutCategoriesInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => UserCreateNestedOneWithoutPostsInput, { nullable: false })
  author!: InstanceType<typeof UserCreateNestedOneWithoutPostsInput>;
  @Field(() => UserCreateNestedOneWithoutAnotherPostsInput, { nullable: false })
  anotherAuthor!: InstanceType<
    typeof UserCreateNestedOneWithoutAnotherPostsInput
  >;
}

@InputType()
export class PostCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => UserCreateNestedOneWithoutPostsInput, { nullable: false })
  author!: InstanceType<typeof UserCreateNestedOneWithoutPostsInput>;
  @Field(() => UserCreateNestedOneWithoutAnotherPostsInput, { nullable: false })
  anotherAuthor!: InstanceType<
    typeof UserCreateNestedOneWithoutAnotherPostsInput
  >;
  @Field(() => CategoryCreateNestedManyWithoutPostsInput, { nullable: true })
  categories?: InstanceType<typeof CategoryCreateNestedManyWithoutPostsInput>;
}

@ArgsType()
export class PostGroupByArgs {
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
  @Field(() => [PostOrderByWithAggregationInput], { nullable: true })
  orderBy?: Array<PostOrderByWithAggregationInput>;
  @Field(() => [PostScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof PostScalarFieldEnum>;
  @Field(() => PostScalarWhereWithAggregatesInput, { nullable: true })
  having?: InstanceType<typeof PostScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => PostCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof PostCountAggregateInput>;
  @Field(() => PostAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof PostAvgAggregateInput>;
  @Field(() => PostSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof PostSumAggregateInput>;
  @Field(() => PostMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof PostMinAggregateInput>;
  @Field(() => PostMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof PostMaxAggregateInput>;
}

@ObjectType()
export class PostGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: false })
  published!: boolean;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => PostCountAggregate, { nullable: true })
  _count?: InstanceType<typeof PostCountAggregate>;
  @Field(() => PostAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof PostAvgAggregate>;
  @Field(() => PostSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof PostSumAggregate>;
  @Field(() => PostMinAggregate, { nullable: true })
  _min?: InstanceType<typeof PostMinAggregate>;
  @Field(() => PostMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof PostMaxAggregate>;
}

@InputType()
export class PostListRelationFilter {
  @Field(() => PostWhereInput, { nullable: true })
  every?: InstanceType<typeof PostWhereInput>;
  @Field(() => PostWhereInput, { nullable: true })
  some?: InstanceType<typeof PostWhereInput>;
  @Field(() => PostWhereInput, { nullable: true })
  none?: InstanceType<typeof PostWhereInput>;
}

@InputType()
export class PostMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  title?: true;
  @Field(() => Boolean, { nullable: true })
  content?: true;
  @Field(() => Boolean, { nullable: true })
  published?: true;
  @Field(() => Boolean, { nullable: true })
  authorId?: true;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: true;
  @Field(() => Boolean, { nullable: true })
  postKind?: true;
}

@ObjectType()
export class PostMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  title?: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: true })
  authorId?: number;
  @Field(() => Int, { nullable: true })
  anotherAuthorId?: number;
  @Field(() => PostKind, { nullable: true })
  postKind?: keyof typeof PostKind;
}

@InputType()
export class PostMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: keyof typeof SortOrder;
}

@InputType()
export class PostMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  title?: true;
  @Field(() => Boolean, { nullable: true })
  content?: true;
  @Field(() => Boolean, { nullable: true })
  published?: true;
  @Field(() => Boolean, { nullable: true })
  authorId?: true;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: true;
  @Field(() => Boolean, { nullable: true })
  postKind?: true;
}

@ObjectType()
export class PostMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  title?: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: true })
  authorId?: number;
  @Field(() => Int, { nullable: true })
  anotherAuthorId?: number;
  @Field(() => PostKind, { nullable: true })
  postKind?: keyof typeof PostKind;
}

@InputType()
export class PostMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  content?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  published?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: keyof typeof SortOrder;
}

@InputType()
export class PostOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: keyof typeof SortOrder;
}

@InputType()
export class PostOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  content?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  published?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: keyof typeof SortOrder;
  @Field(() => PostCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof PostCountOrderByAggregateInput>;
  @Field(() => PostAvgOrderByAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof PostAvgOrderByAggregateInput>;
  @Field(() => PostMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof PostMaxOrderByAggregateInput>;
  @Field(() => PostMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof PostMinOrderByAggregateInput>;
  @Field(() => PostSumOrderByAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof PostSumOrderByAggregateInput>;
}

@InputType()
export class PostOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  title?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  content?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  published?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  postKind?: keyof typeof SortOrder;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  author?: InstanceType<typeof UserOrderByWithRelationInput>;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  anotherAuthor?: InstanceType<typeof UserOrderByWithRelationInput>;
  @Field(() => CategoryOrderByRelationAggregateInput, { nullable: true })
  categories?: InstanceType<typeof CategoryOrderByRelationAggregateInput>;
}

@InputType()
export class PostScalarWhereWithAggregatesInput {
  @Field(() => [PostScalarWhereWithAggregatesInput], { nullable: true })
  AND?: Array<PostScalarWhereWithAggregatesInput>;
  @Field(() => [PostScalarWhereWithAggregatesInput], { nullable: true })
  OR?: Array<PostScalarWhereWithAggregatesInput>;
  @Field(() => [PostScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: Array<PostScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  title?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  content?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => BoolWithAggregatesFilter, { nullable: true })
  published?: InstanceType<typeof BoolWithAggregatesFilter>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  authorId?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => EnumPostKindWithAggregatesFilter, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindWithAggregatesFilter>;
}

@InputType()
export class PostScalarWhereInput {
  @Field(() => [PostScalarWhereInput], { nullable: true })
  AND?: Array<PostScalarWhereInput>;
  @Field(() => [PostScalarWhereInput], { nullable: true })
  OR?: Array<PostScalarWhereInput>;
  @Field(() => [PostScalarWhereInput], { nullable: true })
  NOT?: Array<PostScalarWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  title?: InstanceType<typeof StringFilter>;
  @Field(() => StringFilter, { nullable: true })
  content?: InstanceType<typeof StringFilter>;
  @Field(() => BoolFilter, { nullable: true })
  published?: InstanceType<typeof BoolFilter>;
  @Field(() => IntFilter, { nullable: true })
  authorId?: InstanceType<typeof IntFilter>;
  @Field(() => IntFilter, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFilter>;
  @Field(() => EnumPostKindFilter, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFilter>;
}

@InputType()
export class PostSumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  authorId?: true;
  @Field(() => Boolean, { nullable: true })
  anotherAuthorId?: true;
}

@ObjectType()
export class PostSumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Int, { nullable: true })
  authorId?: number;
  @Field(() => Int, { nullable: true })
  anotherAuthorId?: number;
}

@InputType()
export class PostSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  authorId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  anotherAuthorId?: keyof typeof SortOrder;
}

@InputType()
export class PostUncheckedCreateNestedManyWithoutAnotherAuthorInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAnotherAuthorInput)
  create?: Array<PostCreateWithoutAnotherAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  @Type(() => PostCreateOrConnectWithoutAnotherAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAnotherAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAnotherAuthorInputEnvelope>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
}

@InputType()
export class PostUncheckedCreateNestedManyWithoutAuthorInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAuthorInput)
  create?: Array<PostCreateWithoutAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAuthorInputEnvelope>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
}

@InputType()
export class PostUncheckedCreateNestedManyWithoutCategoriesInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateWithoutCategoriesInput)
  create?: Array<PostCreateWithoutCategoriesInput>;
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutCategoriesInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutCategoriesInput>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
}

@InputType()
export class PostUncheckedCreateWithoutAnotherAuthorInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => CategoryUncheckedCreateNestedManyWithoutPostsInput, {
    nullable: true,
  })
  categories?: InstanceType<
    typeof CategoryUncheckedCreateNestedManyWithoutPostsInput
  >;
}

@InputType()
export class PostUncheckedCreateWithoutAuthorInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => CategoryUncheckedCreateNestedManyWithoutPostsInput, {
    nullable: true,
  })
  categories?: InstanceType<
    typeof CategoryUncheckedCreateNestedManyWithoutPostsInput
  >;
}

@InputType()
export class PostUncheckedCreateWithoutCategoriesInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
}

@InputType()
export class PostUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  title!: string;
  @Field(() => String, { nullable: true })
  content?: string;
  @Field(() => Boolean, { nullable: true })
  published?: boolean;
  @Field(() => Int, { nullable: false })
  authorId!: number;
  @Field(() => Int, { nullable: false })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false })
  postKind!: keyof typeof PostKind;
  @Field(() => CategoryUncheckedCreateNestedManyWithoutPostsInput, {
    nullable: true,
  })
  categories?: InstanceType<
    typeof CategoryUncheckedCreateNestedManyWithoutPostsInput
  >;
}

@InputType()
export class PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAnotherAuthorInput)
  create?: Array<PostCreateWithoutAnotherAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  @Type(() => PostCreateOrConnectWithoutAnotherAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAnotherAuthorInput>;
  @HideField()
  upsert?: Array<PostUpsertWithWhereUniqueWithoutAnotherAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAnotherAuthorInputEnvelope>;
  @HideField()
  set?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostUpdateWithWhereUniqueWithoutAnotherAuthorInput], {
    nullable: true,
  })
  @Type(() => PostUpdateWithWhereUniqueWithoutAnotherAuthorInput)
  update?: Array<PostUpdateWithWhereUniqueWithoutAnotherAuthorInput>;
  @HideField()
  updateMany?: Array<PostUpdateManyWithWhereWithoutAnotherAuthorInput>;
  @HideField()
  deleteMany?: Array<PostScalarWhereInput>;
}

@InputType()
export class PostUncheckedUpdateManyWithoutAnotherAuthorInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  authorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
}

@InputType()
export class PostUncheckedUpdateManyWithoutAuthorNestedInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAuthorInput)
  create?: Array<PostCreateWithoutAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAuthorInput>;
  @HideField()
  upsert?: Array<PostUpsertWithWhereUniqueWithoutAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAuthorInputEnvelope>;
  @HideField()
  set?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostUpdateWithWhereUniqueWithoutAuthorInput], {
    nullable: true,
  })
  @Type(() => PostUpdateWithWhereUniqueWithoutAuthorInput)
  update?: Array<PostUpdateWithWhereUniqueWithoutAuthorInput>;
  @HideField()
  updateMany?: Array<PostUpdateManyWithWhereWithoutAuthorInput>;
  @HideField()
  deleteMany?: Array<PostScalarWhereInput>;
}

@InputType()
export class PostUncheckedUpdateManyWithoutAuthorInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
}

@InputType()
export class PostUncheckedUpdateManyWithoutCategoriesNestedInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateWithoutCategoriesInput)
  create?: Array<PostCreateWithoutCategoriesInput>;
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutCategoriesInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutCategoriesInput>;
  @HideField()
  upsert?: Array<PostUpsertWithWhereUniqueWithoutCategoriesInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostUpdateWithWhereUniqueWithoutCategoriesInput], {
    nullable: true,
  })
  @Type(() => PostUpdateWithWhereUniqueWithoutCategoriesInput)
  update?: Array<PostUpdateWithWhereUniqueWithoutCategoriesInput>;
  @HideField()
  updateMany?: Array<PostUpdateManyWithWhereWithoutCategoriesInput>;
  @HideField()
  deleteMany?: Array<PostScalarWhereInput>;
}

@InputType()
export class PostUncheckedUpdateManyWithoutCategoriesInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  authorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
}

@InputType()
export class PostUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  authorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
}

@InputType()
export class PostUncheckedUpdateWithoutAnotherAuthorInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  authorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => CategoryUncheckedUpdateManyWithoutPostsNestedInput, {
    nullable: true,
  })
  categories?: InstanceType<
    typeof CategoryUncheckedUpdateManyWithoutPostsNestedInput
  >;
}

@InputType()
export class PostUncheckedUpdateWithoutAuthorInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => CategoryUncheckedUpdateManyWithoutPostsNestedInput, {
    nullable: true,
  })
  categories?: InstanceType<
    typeof CategoryUncheckedUpdateManyWithoutPostsNestedInput
  >;
}

@InputType()
export class PostUncheckedUpdateWithoutCategoriesInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  authorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
}

@InputType()
export class PostUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  authorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => CategoryUncheckedUpdateManyWithoutPostsNestedInput, {
    nullable: true,
  })
  categories?: InstanceType<
    typeof CategoryUncheckedUpdateManyWithoutPostsNestedInput
  >;
}

@InputType()
export class PostUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
}

@InputType()
export class PostUpdateManyWithWhereWithoutAnotherAuthorInput {
  @Field(() => PostScalarWhereInput, { nullable: false })
  @Type(() => PostScalarWhereInput)
  where!: InstanceType<typeof PostScalarWhereInput>;
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  @Type(() => PostUpdateManyMutationInput)
  data!: InstanceType<typeof PostUpdateManyMutationInput>;
}

@InputType()
export class PostUpdateManyWithWhereWithoutAuthorInput {
  @Field(() => PostScalarWhereInput, { nullable: false })
  @Type(() => PostScalarWhereInput)
  where!: InstanceType<typeof PostScalarWhereInput>;
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  @Type(() => PostUpdateManyMutationInput)
  data!: InstanceType<typeof PostUpdateManyMutationInput>;
}

@InputType()
export class PostUpdateManyWithWhereWithoutCategoriesInput {
  @Field(() => PostScalarWhereInput, { nullable: false })
  @Type(() => PostScalarWhereInput)
  where!: InstanceType<typeof PostScalarWhereInput>;
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  @Type(() => PostUpdateManyMutationInput)
  data!: InstanceType<typeof PostUpdateManyMutationInput>;
}

@InputType()
export class PostUpdateManyWithoutAnotherAuthorNestedInput {
  @Field(() => [PostCreateWithoutAnotherAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAnotherAuthorInput)
  create?: Array<PostCreateWithoutAnotherAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAnotherAuthorInput], {
    nullable: true,
  })
  @Type(() => PostCreateOrConnectWithoutAnotherAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAnotherAuthorInput>;
  @HideField()
  upsert?: Array<PostUpsertWithWhereUniqueWithoutAnotherAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAnotherAuthorInputEnvelope>;
  @HideField()
  set?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostUpdateWithWhereUniqueWithoutAnotherAuthorInput], {
    nullable: true,
  })
  @Type(() => PostUpdateWithWhereUniqueWithoutAnotherAuthorInput)
  update?: Array<PostUpdateWithWhereUniqueWithoutAnotherAuthorInput>;
  @HideField()
  updateMany?: Array<PostUpdateManyWithWhereWithoutAnotherAuthorInput>;
  @HideField()
  deleteMany?: Array<PostScalarWhereInput>;
}

@InputType()
export class PostUpdateManyWithoutAuthorNestedInput {
  @Field(() => [PostCreateWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateWithoutAuthorInput)
  create?: Array<PostCreateWithoutAuthorInput>;
  @Field(() => [PostCreateOrConnectWithoutAuthorInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutAuthorInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutAuthorInput>;
  @HideField()
  upsert?: Array<PostUpsertWithWhereUniqueWithoutAuthorInput>;
  @HideField()
  createMany?: InstanceType<typeof PostCreateManyAuthorInputEnvelope>;
  @HideField()
  set?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostUpdateWithWhereUniqueWithoutAuthorInput], {
    nullable: true,
  })
  @Type(() => PostUpdateWithWhereUniqueWithoutAuthorInput)
  update?: Array<PostUpdateWithWhereUniqueWithoutAuthorInput>;
  @HideField()
  updateMany?: Array<PostUpdateManyWithWhereWithoutAuthorInput>;
  @HideField()
  deleteMany?: Array<PostScalarWhereInput>;
}

@InputType()
export class PostUpdateManyWithoutCategoriesNestedInput {
  @Field(() => [PostCreateWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateWithoutCategoriesInput)
  create?: Array<PostCreateWithoutCategoriesInput>;
  @Field(() => [PostCreateOrConnectWithoutCategoriesInput], { nullable: true })
  @Type(() => PostCreateOrConnectWithoutCategoriesInput)
  connectOrCreate?: Array<PostCreateOrConnectWithoutCategoriesInput>;
  @HideField()
  upsert?: Array<PostUpsertWithWhereUniqueWithoutCategoriesInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostWhereUniqueInput], { nullable: true })
  @Type(() => PostWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<PostWhereUniqueInput, 'id'>>;
  @Field(() => [PostUpdateWithWhereUniqueWithoutCategoriesInput], {
    nullable: true,
  })
  @Type(() => PostUpdateWithWhereUniqueWithoutCategoriesInput)
  update?: Array<PostUpdateWithWhereUniqueWithoutCategoriesInput>;
  @HideField()
  updateMany?: Array<PostUpdateManyWithWhereWithoutCategoriesInput>;
  @HideField()
  deleteMany?: Array<PostScalarWhereInput>;
}

@InputType()
export class PostUpdateWithWhereUniqueWithoutAnotherAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostUpdateWithoutAnotherAuthorInput, { nullable: false })
  @Type(() => PostUpdateWithoutAnotherAuthorInput)
  data!: InstanceType<typeof PostUpdateWithoutAnotherAuthorInput>;
}

@InputType()
export class PostUpdateWithWhereUniqueWithoutAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostUpdateWithoutAuthorInput, { nullable: false })
  @Type(() => PostUpdateWithoutAuthorInput)
  data!: InstanceType<typeof PostUpdateWithoutAuthorInput>;
}

@InputType()
export class PostUpdateWithWhereUniqueWithoutCategoriesInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostUpdateWithoutCategoriesInput, { nullable: false })
  @Type(() => PostUpdateWithoutCategoriesInput)
  data!: InstanceType<typeof PostUpdateWithoutCategoriesInput>;
}

@InputType()
export class PostUpdateWithoutAnotherAuthorInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => UserUpdateOneRequiredWithoutPostsNestedInput, { nullable: true })
  author?: InstanceType<typeof UserUpdateOneRequiredWithoutPostsNestedInput>;
  @Field(() => CategoryUpdateManyWithoutPostsNestedInput, { nullable: true })
  categories?: InstanceType<typeof CategoryUpdateManyWithoutPostsNestedInput>;
}

@InputType()
export class PostUpdateWithoutAuthorInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => UserUpdateOneRequiredWithoutAnotherPostsNestedInput, {
    nullable: true,
  })
  anotherAuthor?: InstanceType<
    typeof UserUpdateOneRequiredWithoutAnotherPostsNestedInput
  >;
  @Field(() => CategoryUpdateManyWithoutPostsNestedInput, { nullable: true })
  categories?: InstanceType<typeof CategoryUpdateManyWithoutPostsNestedInput>;
}

@InputType()
export class PostUpdateWithoutCategoriesInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => UserUpdateOneRequiredWithoutPostsNestedInput, { nullable: true })
  author?: InstanceType<typeof UserUpdateOneRequiredWithoutPostsNestedInput>;
  @Field(() => UserUpdateOneRequiredWithoutAnotherPostsNestedInput, {
    nullable: true,
  })
  anotherAuthor?: InstanceType<
    typeof UserUpdateOneRequiredWithoutAnotherPostsNestedInput
  >;
}

@InputType()
export class PostUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  title?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  content?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => BoolFieldUpdateOperationsInput, { nullable: true })
  published?: InstanceType<typeof BoolFieldUpdateOperationsInput>;
  @Field(() => EnumPostKindFieldUpdateOperationsInput, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFieldUpdateOperationsInput>;
  @Field(() => UserUpdateOneRequiredWithoutPostsNestedInput, { nullable: true })
  author?: InstanceType<typeof UserUpdateOneRequiredWithoutPostsNestedInput>;
  @Field(() => UserUpdateOneRequiredWithoutAnotherPostsNestedInput, {
    nullable: true,
  })
  anotherAuthor?: InstanceType<
    typeof UserUpdateOneRequiredWithoutAnotherPostsNestedInput
  >;
  @Field(() => CategoryUpdateManyWithoutPostsNestedInput, { nullable: true })
  categories?: InstanceType<typeof CategoryUpdateManyWithoutPostsNestedInput>;
}

@InputType()
export class PostUpsertWithWhereUniqueWithoutAnotherAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostUpdateWithoutAnotherAuthorInput, { nullable: false })
  @Type(() => PostUpdateWithoutAnotherAuthorInput)
  update!: InstanceType<typeof PostUpdateWithoutAnotherAuthorInput>;
  @Field(() => PostCreateWithoutAnotherAuthorInput, { nullable: false })
  @Type(() => PostCreateWithoutAnotherAuthorInput)
  create!: InstanceType<typeof PostCreateWithoutAnotherAuthorInput>;
}

@InputType()
export class PostUpsertWithWhereUniqueWithoutAuthorInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostUpdateWithoutAuthorInput, { nullable: false })
  @Type(() => PostUpdateWithoutAuthorInput)
  update!: InstanceType<typeof PostUpdateWithoutAuthorInput>;
  @Field(() => PostCreateWithoutAuthorInput, { nullable: false })
  @Type(() => PostCreateWithoutAuthorInput)
  create!: InstanceType<typeof PostCreateWithoutAuthorInput>;
}

@InputType()
export class PostUpsertWithWhereUniqueWithoutCategoriesInput {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostUpdateWithoutCategoriesInput, { nullable: false })
  @Type(() => PostUpdateWithoutCategoriesInput)
  update!: InstanceType<typeof PostUpdateWithoutCategoriesInput>;
  @Field(() => PostCreateWithoutCategoriesInput, { nullable: false })
  @Type(() => PostCreateWithoutCategoriesInput)
  create!: InstanceType<typeof PostCreateWithoutCategoriesInput>;
}

@InputType()
export class PostWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => [PostWhereInput], { nullable: true })
  AND?: Array<PostWhereInput>;
  @Field(() => [PostWhereInput], { nullable: true })
  OR?: Array<PostWhereInput>;
  @Field(() => [PostWhereInput], { nullable: true })
  NOT?: Array<PostWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  title?: InstanceType<typeof StringFilter>;
  @Field(() => StringFilter, { nullable: true })
  content?: InstanceType<typeof StringFilter>;
  @Field(() => BoolFilter, { nullable: true })
  published?: InstanceType<typeof BoolFilter>;
  @Field(() => IntFilter, { nullable: true })
  authorId?: InstanceType<typeof IntFilter>;
  @Field(() => IntFilter, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFilter>;
  @Field(() => EnumPostKindFilter, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  author?: InstanceType<typeof UserRelationFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  anotherAuthor?: InstanceType<typeof UserRelationFilter>;
  @Field(() => CategoryListRelationFilter, { nullable: true })
  categories?: InstanceType<typeof CategoryListRelationFilter>;
}

@InputType()
export class PostWhereInput {
  @Field(() => [PostWhereInput], { nullable: true })
  AND?: Array<PostWhereInput>;
  @Field(() => [PostWhereInput], { nullable: true })
  OR?: Array<PostWhereInput>;
  @Field(() => [PostWhereInput], { nullable: true })
  NOT?: Array<PostWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  title?: InstanceType<typeof StringFilter>;
  @Field(() => StringFilter, { nullable: true })
  content?: InstanceType<typeof StringFilter>;
  @Field(() => BoolFilter, { nullable: true })
  published?: InstanceType<typeof BoolFilter>;
  @Field(() => IntFilter, { nullable: true })
  authorId?: InstanceType<typeof IntFilter>;
  @Field(() => IntFilter, { nullable: true })
  anotherAuthorId?: InstanceType<typeof IntFilter>;
  @Field(() => EnumPostKindFilter, { nullable: true })
  postKind?: InstanceType<typeof EnumPostKindFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  author?: InstanceType<typeof UserRelationFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  anotherAuthor?: InstanceType<typeof UserRelationFilter>;
  @Field(() => CategoryListRelationFilter, { nullable: true })
  categories?: InstanceType<typeof CategoryListRelationFilter>;
}

/**
 * @
 * @allow ('all', auth().role == 'ADMIN')
 */
@ObjectType({ description: "@@allow('all', auth().role == 'ADMIN')" })
export class Post {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  @Field(() => String, { nullable: false, description: '' })
  title!: string;
  @Field(() => String, { nullable: true, description: '' })
  content!: string | null;
  @Field(() => Boolean, {
    nullable: false,
    defaultValue: false,
    description: '',
  })
  published!: boolean;
  @Field(() => Int, { nullable: false, description: '' })
  authorId!: number;
  @Field(() => Int, { nullable: false, description: '' })
  anotherAuthorId!: number;
  @Field(() => PostKind, { nullable: false, description: '' })
  postKind!: keyof typeof PostKind;
  /**
   * Many to one relation with User
   */
  @Field(() => User, {
    nullable: false,
    description: 'Many to one relation with User',
  })
  author?: InstanceType<typeof User>;
  /**
   * Another Many to one relation with User
   */
  @Field(() => User, {
    nullable: false,
    description: 'Another Many to one relation with User',
  })
  anotherAuthor?: InstanceType<typeof User>;
  /**
   * Many to many relation with Category
   */
  @Field(() => [Category], {
    nullable: true,
    description: 'Many to many relation with Category',
  })
  categories?: Array<Category>;
}

@ArgsType()
export class UpdateManyPostArgs {
  @Field(() => PostUpdateManyMutationInput, { nullable: false })
  @Type(() => PostUpdateManyMutationInput)
  data!: InstanceType<typeof PostUpdateManyMutationInput>;
  @Field(() => PostWhereInput, { nullable: true })
  @Type(() => PostWhereInput)
  where?: InstanceType<typeof PostWhereInput>;
}

@ArgsType()
export class UpdateOnePostArgs {
  @Field(() => PostUpdateInput, { nullable: false })
  @Type(() => PostUpdateInput)
  data!: InstanceType<typeof PostUpdateInput>;
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
}

@ArgsType()
export class UpsertOnePostArgs {
  @Field(() => PostWhereUniqueInput, { nullable: false })
  @Type(() => PostWhereUniqueInput)
  where!: Prisma.AtLeast<PostWhereUniqueInput, 'id'>;
  @Field(() => PostCreateInput, { nullable: false })
  @Type(() => PostCreateInput)
  create!: InstanceType<typeof PostCreateInput>;
  @Field(() => PostUpdateInput, { nullable: false })
  @Type(() => PostUpdateInput)
  update!: InstanceType<typeof PostUpdateInput>;
}

@ObjectType()
export class AffectedRows {
  @Field(() => Int, { nullable: false })
  count!: number;
}

@InputType()
export class BigIntFieldUpdateOperationsInput {
  @Field(() => GraphQLBigInt, { nullable: true })
  set?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  increment?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  decrement?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  multiply?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  divide?: bigint | number;
}

@InputType()
export class BigIntFilter {
  @Field(() => GraphQLBigInt, { nullable: true })
  equals?: bigint | number;
  @Field(() => [GraphQLBigInt], { nullable: true })
  in?: Array<bigint> | Array<number>;
  @Field(() => [GraphQLBigInt], { nullable: true })
  notIn?: Array<bigint> | Array<number>;
  @Field(() => GraphQLBigInt, { nullable: true })
  lt?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  lte?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  gt?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  gte?: bigint | number;
  @Field(() => BigIntFilter, { nullable: true })
  not?: InstanceType<typeof BigIntFilter>;
}

@InputType()
export class BigIntListFilter {
  @Field(() => [GraphQLBigInt], { nullable: true })
  equals?: Array<bigint> | Array<number>;
  @Field(() => GraphQLBigInt, { nullable: true })
  has?: bigint | number;
  @Field(() => [GraphQLBigInt], { nullable: true })
  hasEvery?: Array<bigint> | Array<number>;
  @Field(() => [GraphQLBigInt], { nullable: true })
  hasSome?: Array<bigint> | Array<number>;
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class BigIntWithAggregatesFilter {
  @Field(() => GraphQLBigInt, { nullable: true })
  equals?: bigint | number;
  @Field(() => [GraphQLBigInt], { nullable: true })
  in?: Array<bigint> | Array<number>;
  @Field(() => [GraphQLBigInt], { nullable: true })
  notIn?: Array<bigint> | Array<number>;
  @Field(() => GraphQLBigInt, { nullable: true })
  lt?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  lte?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  gt?: bigint | number;
  @Field(() => GraphQLBigInt, { nullable: true })
  gte?: bigint | number;
  @Field(() => BigIntWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof BigIntWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => FloatFilter, { nullable: true })
  _avg?: InstanceType<typeof FloatFilter>;
  @Field(() => BigIntFilter, { nullable: true })
  _sum?: InstanceType<typeof BigIntFilter>;
  @Field(() => BigIntFilter, { nullable: true })
  _min?: InstanceType<typeof BigIntFilter>;
  @Field(() => BigIntFilter, { nullable: true })
  _max?: InstanceType<typeof BigIntFilter>;
}

@InputType()
export class BoolFieldUpdateOperationsInput {
  @Field(() => Boolean, { nullable: true })
  set?: boolean;
}

@InputType()
export class BoolFilter {
  @Field(() => Boolean, { nullable: true })
  equals?: boolean;
  @Field(() => BoolFilter, { nullable: true })
  not?: InstanceType<typeof BoolFilter>;
}

@InputType()
export class BoolWithAggregatesFilter {
  @Field(() => Boolean, { nullable: true })
  equals?: boolean;
  @Field(() => BoolWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof BoolWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => BoolFilter, { nullable: true })
  _min?: InstanceType<typeof BoolFilter>;
  @Field(() => BoolFilter, { nullable: true })
  _max?: InstanceType<typeof BoolFilter>;
}

@InputType()
export class BytesFieldUpdateOperationsInput {
  @Field(() => String, { nullable: true })
  set?: Buffer;
}

@InputType()
export class BytesFilter {
  @Field(() => String, { nullable: true })
  equals?: Buffer;
  @Field(() => [String], { nullable: true })
  in?: Array<Buffer>;
  @Field(() => [String], { nullable: true })
  notIn?: Array<Buffer>;
  @Field(() => BytesFilter, { nullable: true })
  not?: InstanceType<typeof BytesFilter>;
}

@InputType()
export class BytesListFilter {
  @Field(() => [String], { nullable: true })
  equals?: Array<Buffer>;
  @Field(() => String, { nullable: true })
  has?: Buffer;
  @Field(() => [String], { nullable: true })
  hasEvery?: Array<Buffer>;
  @Field(() => [String], { nullable: true })
  hasSome?: Array<Buffer>;
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class BytesWithAggregatesFilter {
  @Field(() => String, { nullable: true })
  equals?: Buffer;
  @Field(() => [String], { nullable: true })
  in?: Array<Buffer>;
  @Field(() => [String], { nullable: true })
  notIn?: Array<Buffer>;
  @Field(() => BytesWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof BytesWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => BytesFilter, { nullable: true })
  _min?: InstanceType<typeof BytesFilter>;
  @Field(() => BytesFilter, { nullable: true })
  _max?: InstanceType<typeof BytesFilter>;
}

@InputType()
export class DateTimeFieldUpdateOperationsInput {
  @Field(() => Date, { nullable: true })
  set?: Date | string;
}

@InputType()
export class DateTimeFilter {
  @Field(() => Date, { nullable: true })
  equals?: Date | string;
  @Field(() => [Date], { nullable: true })
  in?: Array<Date> | Array<string>;
  @Field(() => [Date], { nullable: true })
  notIn?: Array<Date> | Array<string>;
  @Field(() => Date, { nullable: true })
  lt?: Date | string;
  @Field(() => Date, { nullable: true })
  lte?: Date | string;
  @Field(() => Date, { nullable: true })
  gt?: Date | string;
  @Field(() => Date, { nullable: true })
  gte?: Date | string;
  @Field(() => DateTimeFilter, { nullable: true })
  not?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class DateTimeListFilter {
  @Field(() => [Date], { nullable: true })
  equals?: Array<Date> | Array<string>;
  @Field(() => Date, { nullable: true })
  has?: Date | string;
  @Field(() => [Date], { nullable: true })
  hasEvery?: Array<Date> | Array<string>;
  @Field(() => [Date], { nullable: true })
  hasSome?: Array<Date> | Array<string>;
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class DateTimeWithAggregatesFilter {
  @Field(() => Date, { nullable: true })
  equals?: Date | string;
  @Field(() => [Date], { nullable: true })
  in?: Array<Date> | Array<string>;
  @Field(() => [Date], { nullable: true })
  notIn?: Array<Date> | Array<string>;
  @Field(() => Date, { nullable: true })
  lt?: Date | string;
  @Field(() => Date, { nullable: true })
  lte?: Date | string;
  @Field(() => Date, { nullable: true })
  gt?: Date | string;
  @Field(() => Date, { nullable: true })
  gte?: Date | string;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  _min?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  _max?: InstanceType<typeof DateTimeFilter>;
}

@InputType()
export class DecimalFieldUpdateOperationsInput {
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  set?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  increment?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  decrement?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  multiply?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  divide?: Decimal;
}

@InputType()
export class DecimalFilter {
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  equals?: Decimal;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  in?: Array<Decimal>;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  notIn?: Array<Decimal>;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  lt?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  lte?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  gt?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  gte?: Decimal;
  @Field(() => DecimalFilter, { nullable: true })
  not?: InstanceType<typeof DecimalFilter>;
}

@InputType()
export class DecimalListFilter {
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  equals?: Array<Decimal>;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  has?: Decimal;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  hasEvery?: Array<Decimal>;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  hasSome?: Array<Decimal>;
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class DecimalWithAggregatesFilter {
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  equals?: Decimal;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  in?: Array<Decimal>;
  @Field(() => [GraphQLDecimal], { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  notIn?: Array<Decimal>;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  lt?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  lte?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  gt?: Decimal;
  @Field(() => GraphQLDecimal, { nullable: true })
  @Type(() => Object)
  @Transform(transformToDecimal)
  gte?: Decimal;
  @Field(() => DecimalWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof DecimalWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => DecimalFilter, { nullable: true })
  _avg?: InstanceType<typeof DecimalFilter>;
  @Field(() => DecimalFilter, { nullable: true })
  _sum?: InstanceType<typeof DecimalFilter>;
  @Field(() => DecimalFilter, { nullable: true })
  _min?: InstanceType<typeof DecimalFilter>;
  @Field(() => DecimalFilter, { nullable: true })
  _max?: InstanceType<typeof DecimalFilter>;
}

@InputType()
export class EnumPostKindFieldUpdateOperationsInput {
  @Field(() => PostKind, { nullable: true })
  set?: keyof typeof PostKind;
}

@InputType()
export class EnumPostKindFilter {
  @Field(() => PostKind, { nullable: true })
  equals?: keyof typeof PostKind;
  @Field(() => [PostKind], { nullable: true })
  in?: Array<keyof typeof PostKind>;
  @Field(() => [PostKind], { nullable: true })
  notIn?: Array<keyof typeof PostKind>;
  @Field(() => EnumPostKindFilter, { nullable: true })
  not?: InstanceType<typeof EnumPostKindFilter>;
}

@InputType()
export class EnumPostKindWithAggregatesFilter {
  @Field(() => PostKind, { nullable: true })
  equals?: keyof typeof PostKind;
  @Field(() => [PostKind], { nullable: true })
  in?: Array<keyof typeof PostKind>;
  @Field(() => [PostKind], { nullable: true })
  notIn?: Array<keyof typeof PostKind>;
  @Field(() => EnumPostKindWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof EnumPostKindWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => EnumPostKindFilter, { nullable: true })
  _min?: InstanceType<typeof EnumPostKindFilter>;
  @Field(() => EnumPostKindFilter, { nullable: true })
  _max?: InstanceType<typeof EnumPostKindFilter>;
}

@InputType()
export class EnumUserRoleFieldUpdateOperationsInput {
  @Field(() => UserRole, { nullable: true })
  set?: keyof typeof UserRole;
}

@InputType()
export class EnumUserRoleFilter {
  @Field(() => UserRole, { nullable: true })
  equals?: keyof typeof UserRole;
  @Field(() => [UserRole], { nullable: true })
  in?: Array<keyof typeof UserRole>;
  @Field(() => [UserRole], { nullable: true })
  notIn?: Array<keyof typeof UserRole>;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  not?: InstanceType<typeof EnumUserRoleFilter>;
}

@InputType()
export class EnumUserRoleWithAggregatesFilter {
  @Field(() => UserRole, { nullable: true })
  equals?: keyof typeof UserRole;
  @Field(() => [UserRole], { nullable: true })
  in?: Array<keyof typeof UserRole>;
  @Field(() => [UserRole], { nullable: true })
  notIn?: Array<keyof typeof UserRole>;
  @Field(() => EnumUserRoleWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof EnumUserRoleWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  _min?: InstanceType<typeof EnumUserRoleFilter>;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  _max?: InstanceType<typeof EnumUserRoleFilter>;
}

@InputType()
export class FloatFieldUpdateOperationsInput {
  @Field(() => Float, { nullable: true })
  set?: number;
  @Field(() => Float, { nullable: true })
  increment?: number;
  @Field(() => Float, { nullable: true })
  decrement?: number;
  @Field(() => Float, { nullable: true })
  multiply?: number;
  @Field(() => Float, { nullable: true })
  divide?: number;
}

@InputType()
export class FloatFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: Array<number>;
  @Field(() => [Float], { nullable: true })
  notIn?: Array<number>;
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => FloatFilter, { nullable: true })
  not?: InstanceType<typeof FloatFilter>;
}

@InputType()
export class FloatWithAggregatesFilter {
  @Field(() => Float, { nullable: true })
  equals?: number;
  @Field(() => [Float], { nullable: true })
  in?: Array<number>;
  @Field(() => [Float], { nullable: true })
  notIn?: Array<number>;
  @Field(() => Float, { nullable: true })
  lt?: number;
  @Field(() => Float, { nullable: true })
  lte?: number;
  @Field(() => Float, { nullable: true })
  gt?: number;
  @Field(() => Float, { nullable: true })
  gte?: number;
  @Field(() => FloatWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof FloatWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => FloatFilter, { nullable: true })
  _avg?: InstanceType<typeof FloatFilter>;
  @Field(() => FloatFilter, { nullable: true })
  _sum?: InstanceType<typeof FloatFilter>;
  @Field(() => FloatFilter, { nullable: true })
  _min?: InstanceType<typeof FloatFilter>;
  @Field(() => FloatFilter, { nullable: true })
  _max?: InstanceType<typeof FloatFilter>;
}

@InputType()
export class IntFieldUpdateOperationsInput {
  @Field(() => Int, { nullable: true })
  set?: number;
  @Field(() => Int, { nullable: true })
  increment?: number;
  @Field(() => Int, { nullable: true })
  decrement?: number;
  @Field(() => Int, { nullable: true })
  multiply?: number;
  @Field(() => Int, { nullable: true })
  divide?: number;
}

@InputType()
export class IntFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: Array<number>;
  @Field(() => [Int], { nullable: true })
  notIn?: Array<number>;
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => IntFilter, { nullable: true })
  not?: InstanceType<typeof IntFilter>;
}

@InputType()
export class IntWithAggregatesFilter {
  @Field(() => Int, { nullable: true })
  equals?: number;
  @Field(() => [Int], { nullable: true })
  in?: Array<number>;
  @Field(() => [Int], { nullable: true })
  notIn?: Array<number>;
  @Field(() => Int, { nullable: true })
  lt?: number;
  @Field(() => Int, { nullable: true })
  lte?: number;
  @Field(() => Int, { nullable: true })
  gt?: number;
  @Field(() => Int, { nullable: true })
  gte?: number;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => FloatFilter, { nullable: true })
  _avg?: InstanceType<typeof FloatFilter>;
  @Field(() => IntFilter, { nullable: true })
  _sum?: InstanceType<typeof IntFilter>;
  @Field(() => IntFilter, { nullable: true })
  _min?: InstanceType<typeof IntFilter>;
  @Field(() => IntFilter, { nullable: true })
  _max?: InstanceType<typeof IntFilter>;
}

@InputType()
export class JsonFilter {
  @Field(() => GraphQLJSON, { nullable: true })
  equals?: any;
  @Field(() => [String], { nullable: true })
  path?: Array<string>;
  @Field(() => String, { nullable: true })
  string_contains?: string;
  @Field(() => String, { nullable: true })
  string_starts_with?: string;
  @Field(() => String, { nullable: true })
  string_ends_with?: string;
  @Field(() => GraphQLJSON, { nullable: true })
  array_contains?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_starts_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_ends_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  not?: any;
}

@InputType()
export class JsonListFilter {
  @Field(() => [GraphQLJSON], { nullable: true })
  equals?: Array<any>;
  @Field(() => GraphQLJSON, { nullable: true })
  has?: any;
  @Field(() => [GraphQLJSON], { nullable: true })
  hasEvery?: Array<any>;
  @Field(() => [GraphQLJSON], { nullable: true })
  hasSome?: Array<any>;
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class JsonWithAggregatesFilter {
  @Field(() => GraphQLJSON, { nullable: true })
  equals?: any;
  @Field(() => [String], { nullable: true })
  path?: Array<string>;
  @Field(() => String, { nullable: true })
  string_contains?: string;
  @Field(() => String, { nullable: true })
  string_starts_with?: string;
  @Field(() => String, { nullable: true })
  string_ends_with?: string;
  @Field(() => GraphQLJSON, { nullable: true })
  array_contains?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_starts_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  array_ends_with?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  lte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gt?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  gte?: any;
  @Field(() => GraphQLJSON, { nullable: true })
  not?: any;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => JsonFilter, { nullable: true })
  _min?: InstanceType<typeof JsonFilter>;
  @Field(() => JsonFilter, { nullable: true })
  _max?: InstanceType<typeof JsonFilter>;
}

@InputType()
export class NullableIntFieldUpdateOperationsInput {
  @Field(() => Int, { nullable: true })
  set?: number;
  @Field(() => Int, { nullable: true })
  increment?: number;
  @Field(() => Int, { nullable: true })
  decrement?: number;
  @Field(() => Int, { nullable: true })
  multiply?: number;
  @Field(() => Int, { nullable: true })
  divide?: number;
}

@InputType()
export class NullableStringFieldUpdateOperationsInput {
  @Field(() => String, { nullable: true })
  set?: string;
}

@InputType()
export class SortOrderInput {
  @Field(() => SortOrder, { nullable: false })
  sort!: keyof typeof SortOrder;
  @Field(() => NullsOrder, { nullable: true })
  nulls?: keyof typeof NullsOrder;
}

@InputType()
export class StringFieldUpdateOperationsInput {
  @Field(() => String, { nullable: true })
  set?: string;
}

@InputType()
export class StringFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: Array<string>;
  @Field(() => [String], { nullable: true })
  notIn?: Array<string>;
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => QueryMode, { nullable: true })
  mode?: keyof typeof QueryMode;
  @Field(() => StringFilter, { nullable: true })
  not?: InstanceType<typeof StringFilter>;
}

@InputType()
export class StringListFilter {
  @Field(() => [String], { nullable: true })
  equals?: Array<string>;
  @Field(() => String, { nullable: true })
  has?: string;
  @Field(() => [String], { nullable: true })
  hasEvery?: Array<string>;
  @Field(() => [String], { nullable: true })
  hasSome?: Array<string>;
  @Field(() => Boolean, { nullable: true })
  isEmpty?: boolean;
}

@InputType()
export class StringWithAggregatesFilter {
  @Field(() => String, { nullable: true })
  equals?: string;
  @Field(() => [String], { nullable: true })
  in?: Array<string>;
  @Field(() => [String], { nullable: true })
  notIn?: Array<string>;
  @Field(() => String, { nullable: true })
  lt?: string;
  @Field(() => String, { nullable: true })
  lte?: string;
  @Field(() => String, { nullable: true })
  gt?: string;
  @Field(() => String, { nullable: true })
  gte?: string;
  @Field(() => String, { nullable: true })
  contains?: string;
  @Field(() => String, { nullable: true })
  startsWith?: string;
  @Field(() => String, { nullable: true })
  endsWith?: string;
  @Field(() => QueryMode, { nullable: true })
  mode?: keyof typeof QueryMode;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  not?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => IntFilter, { nullable: true })
  _count?: InstanceType<typeof IntFilter>;
  @Field(() => StringFilter, { nullable: true })
  _min?: InstanceType<typeof StringFilter>;
  @Field(() => StringFilter, { nullable: true })
  _max?: InstanceType<typeof StringFilter>;
}

@ObjectType()
export class AggregateProfile {
  @Field(() => ProfileCountAggregate, { nullable: true })
  _count?: InstanceType<typeof ProfileCountAggregate>;
  @Field(() => ProfileAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof ProfileAvgAggregate>;
  @Field(() => ProfileSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof ProfileSumAggregate>;
  @Field(() => ProfileMinAggregate, { nullable: true })
  _min?: InstanceType<typeof ProfileMinAggregate>;
  @Field(() => ProfileMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof ProfileMaxAggregate>;
}

@ArgsType()
export class CreateManyProfileArgs {
  @Field(() => [ProfileCreateManyInput], { nullable: false })
  @Type(() => ProfileCreateManyInput)
  data!: Array<ProfileCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneProfileArgs {
  @Field(() => ProfileCreateInput, { nullable: false })
  @Type(() => ProfileCreateInput)
  data!: InstanceType<typeof ProfileCreateInput>;
}

@ArgsType()
export class DeleteManyProfileArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
}

@ArgsType()
export class DeleteOneProfileArgs {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  @Type(() => ProfileWhereUniqueInput)
  where!: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
}

@ArgsType()
export class FindFirstProfileOrThrowArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<ProfileOrderByWithRelationInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [ProfileScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof ProfileScalarFieldEnum>;
}

@ArgsType()
export class FindFirstProfileArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<ProfileOrderByWithRelationInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [ProfileScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof ProfileScalarFieldEnum>;
}

@ArgsType()
export class FindManyProfileArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<ProfileOrderByWithRelationInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [ProfileScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof ProfileScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueProfileOrThrowArgs {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  @Type(() => ProfileWhereUniqueInput)
  where!: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
}

@ArgsType()
export class FindUniqueProfileArgs {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  @Type(() => ProfileWhereUniqueInput)
  where!: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
}

@ArgsType()
export class ProfileAggregateArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => [ProfileOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<ProfileOrderByWithRelationInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => ProfileCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof ProfileCountAggregateInput>;
  @Field(() => ProfileAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof ProfileAvgAggregateInput>;
  @Field(() => ProfileSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof ProfileSumAggregateInput>;
  @Field(() => ProfileMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof ProfileMinAggregateInput>;
  @Field(() => ProfileMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof ProfileMaxAggregateInput>;
}

@InputType()
export class ProfileAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  userId?: true;
}

@ObjectType()
export class ProfileAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
  @Field(() => Float, { nullable: true })
  userId?: number;
}

@InputType()
export class ProfileAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
}

@InputType()
export class ProfileCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  bio?: true;
  @Field(() => Boolean, { nullable: true })
  userId?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class ProfileCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  bio!: number;
  @Field(() => Int, { nullable: false })
  userId!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class ProfileCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
}

@InputType()
export class ProfileCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => Int, { nullable: false })
  userId!: number;
}

@InputType()
export class ProfileCreateNestedOneWithoutUserInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateWithoutUserInput)
  create?: InstanceType<typeof ProfileCreateWithoutUserInput>;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateOrConnectWithoutUserInput)
  connectOrCreate?: InstanceType<typeof ProfileCreateOrConnectWithoutUserInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  @Type(() => ProfileWhereUniqueInput)
  connect?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
}

@InputType()
export class ProfileCreateOrConnectWithoutUserInput {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  @Type(() => ProfileWhereUniqueInput)
  where!: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => ProfileCreateWithoutUserInput, { nullable: false })
  @Type(() => ProfileCreateWithoutUserInput)
  create!: InstanceType<typeof ProfileCreateWithoutUserInput>;
}

@InputType()
export class ProfileCreateWithoutUserInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
}

@InputType()
export class ProfileCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => UserCreateNestedOneWithoutProfileInput, { nullable: false })
  user!: InstanceType<typeof UserCreateNestedOneWithoutProfileInput>;
}

@ArgsType()
export class ProfileGroupByArgs {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => [ProfileOrderByWithAggregationInput], { nullable: true })
  orderBy?: Array<ProfileOrderByWithAggregationInput>;
  @Field(() => [ProfileScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof ProfileScalarFieldEnum>;
  @Field(() => ProfileScalarWhereWithAggregatesInput, { nullable: true })
  having?: InstanceType<typeof ProfileScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => ProfileCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof ProfileCountAggregateInput>;
  @Field(() => ProfileAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof ProfileAvgAggregateInput>;
  @Field(() => ProfileSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof ProfileSumAggregateInput>;
  @Field(() => ProfileMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof ProfileMinAggregateInput>;
  @Field(() => ProfileMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof ProfileMaxAggregateInput>;
}

@ObjectType()
export class ProfileGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => Int, { nullable: false })
  userId!: number;
  @Field(() => ProfileCountAggregate, { nullable: true })
  _count?: InstanceType<typeof ProfileCountAggregate>;
  @Field(() => ProfileAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof ProfileAvgAggregate>;
  @Field(() => ProfileSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof ProfileSumAggregate>;
  @Field(() => ProfileMinAggregate, { nullable: true })
  _min?: InstanceType<typeof ProfileMinAggregate>;
  @Field(() => ProfileMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof ProfileMaxAggregate>;
}

@InputType()
export class ProfileMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  bio?: true;
  @Field(() => Boolean, { nullable: true })
  userId?: true;
}

@ObjectType()
export class ProfileMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => Int, { nullable: true })
  userId?: number;
}

@InputType()
export class ProfileMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
}

@InputType()
export class ProfileMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  bio?: true;
  @Field(() => Boolean, { nullable: true })
  userId?: true;
}

@ObjectType()
export class ProfileMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => Int, { nullable: true })
  userId?: number;
}

@InputType()
export class ProfileMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  bio?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
}

@InputType()
export class ProfileOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  bio?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
  @Field(() => ProfileCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof ProfileCountOrderByAggregateInput>;
  @Field(() => ProfileAvgOrderByAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof ProfileAvgOrderByAggregateInput>;
  @Field(() => ProfileMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof ProfileMaxOrderByAggregateInput>;
  @Field(() => ProfileMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof ProfileMinOrderByAggregateInput>;
  @Field(() => ProfileSumOrderByAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof ProfileSumOrderByAggregateInput>;
}

@InputType()
export class ProfileOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  bio?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  user?: InstanceType<typeof UserOrderByWithRelationInput>;
}

@InputType()
export class ProfileRelationFilter {
  @Field(() => ProfileWhereInput, { nullable: true })
  is?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  isNot?: InstanceType<typeof ProfileWhereInput>;
}

@InputType()
export class ProfileScalarWhereWithAggregatesInput {
  @Field(() => [ProfileScalarWhereWithAggregatesInput], { nullable: true })
  AND?: Array<ProfileScalarWhereWithAggregatesInput>;
  @Field(() => [ProfileScalarWhereWithAggregatesInput], { nullable: true })
  OR?: Array<ProfileScalarWhereWithAggregatesInput>;
  @Field(() => [ProfileScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: Array<ProfileScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  bio?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  userId?: InstanceType<typeof IntWithAggregatesFilter>;
}

@InputType()
export class ProfileSumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  userId?: true;
}

@ObjectType()
export class ProfileSumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Int, { nullable: true })
  userId?: number;
}

@InputType()
export class ProfileSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  userId?: keyof typeof SortOrder;
}

@InputType()
export class ProfileUncheckedCreateNestedOneWithoutUserInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateWithoutUserInput)
  create?: InstanceType<typeof ProfileCreateWithoutUserInput>;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateOrConnectWithoutUserInput)
  connectOrCreate?: InstanceType<typeof ProfileCreateOrConnectWithoutUserInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  @Type(() => ProfileWhereUniqueInput)
  connect?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
}

@InputType()
export class ProfileUncheckedCreateWithoutUserInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
}

@InputType()
export class ProfileUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  bio?: string;
  @Field(() => Int, { nullable: false })
  userId!: number;
}

@InputType()
export class ProfileUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  userId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class ProfileUncheckedUpdateOneWithoutUserNestedInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateWithoutUserInput)
  create?: InstanceType<typeof ProfileCreateWithoutUserInput>;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateOrConnectWithoutUserInput)
  connectOrCreate?: InstanceType<typeof ProfileCreateOrConnectWithoutUserInput>;
  @HideField()
  upsert?: InstanceType<typeof ProfileUpsertWithoutUserInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  disconnect?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  delete?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  @Type(() => ProfileWhereUniqueInput)
  connect?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => ProfileUpdateToOneWithWhereWithoutUserInput, { nullable: true })
  @Type(() => ProfileUpdateToOneWithWhereWithoutUserInput)
  update?: InstanceType<typeof ProfileUpdateToOneWithWhereWithoutUserInput>;
}

@InputType()
export class ProfileUncheckedUpdateWithoutUserInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class ProfileUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  userId?: InstanceType<typeof IntFieldUpdateOperationsInput>;
}

@InputType()
export class ProfileUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class ProfileUpdateOneWithoutUserNestedInput {
  @Field(() => ProfileCreateWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateWithoutUserInput)
  create?: InstanceType<typeof ProfileCreateWithoutUserInput>;
  @Field(() => ProfileCreateOrConnectWithoutUserInput, { nullable: true })
  @Type(() => ProfileCreateOrConnectWithoutUserInput)
  connectOrCreate?: InstanceType<typeof ProfileCreateOrConnectWithoutUserInput>;
  @HideField()
  upsert?: InstanceType<typeof ProfileUpsertWithoutUserInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  disconnect?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  delete?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: true })
  @Type(() => ProfileWhereUniqueInput)
  connect?: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => ProfileUpdateToOneWithWhereWithoutUserInput, { nullable: true })
  @Type(() => ProfileUpdateToOneWithWhereWithoutUserInput)
  update?: InstanceType<typeof ProfileUpdateToOneWithWhereWithoutUserInput>;
}

@InputType()
export class ProfileUpdateToOneWithWhereWithoutUserInput {
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
  @Field(() => ProfileUpdateWithoutUserInput, { nullable: false })
  @Type(() => ProfileUpdateWithoutUserInput)
  data!: InstanceType<typeof ProfileUpdateWithoutUserInput>;
}

@InputType()
export class ProfileUpdateWithoutUserInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
}

@InputType()
export class ProfileUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  bio?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => UserUpdateOneRequiredWithoutProfileNestedInput, {
    nullable: true,
  })
  user?: InstanceType<typeof UserUpdateOneRequiredWithoutProfileNestedInput>;
}

@InputType()
export class ProfileUpsertWithoutUserInput {
  @Field(() => ProfileUpdateWithoutUserInput, { nullable: false })
  @Type(() => ProfileUpdateWithoutUserInput)
  update!: InstanceType<typeof ProfileUpdateWithoutUserInput>;
  @Field(() => ProfileCreateWithoutUserInput, { nullable: false })
  @Type(() => ProfileCreateWithoutUserInput)
  create!: InstanceType<typeof ProfileCreateWithoutUserInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
}

@InputType()
export class ProfileWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => Int, { nullable: true })
  userId!: number;
  @Field(() => [ProfileWhereInput], { nullable: true })
  AND?: Array<ProfileWhereInput>;
  @Field(() => [ProfileWhereInput], { nullable: true })
  OR?: Array<ProfileWhereInput>;
  @Field(() => [ProfileWhereInput], { nullable: true })
  NOT?: Array<ProfileWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  bio?: InstanceType<typeof StringFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  user?: InstanceType<typeof UserRelationFilter>;
}

@InputType()
export class ProfileWhereInput {
  @Field(() => [ProfileWhereInput], { nullable: true })
  AND?: Array<ProfileWhereInput>;
  @Field(() => [ProfileWhereInput], { nullable: true })
  OR?: Array<ProfileWhereInput>;
  @Field(() => [ProfileWhereInput], { nullable: true })
  NOT?: Array<ProfileWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  bio?: InstanceType<typeof StringFilter>;
  @Field(() => IntFilter, { nullable: true })
  userId?: InstanceType<typeof IntFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  user?: InstanceType<typeof UserRelationFilter>;
}

@ObjectType()
export class Profile {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  @Field(() => String, { nullable: true, description: '' })
  bio!: string | null;
  @Field(() => Int, { nullable: false, description: '' })
  userId!: number;
  @Field(() => User, { nullable: false, description: '' })
  user?: InstanceType<typeof User>;
}

@ArgsType()
export class UpdateManyProfileArgs {
  @Field(() => ProfileUpdateManyMutationInput, { nullable: false })
  @Type(() => ProfileUpdateManyMutationInput)
  data!: InstanceType<typeof ProfileUpdateManyMutationInput>;
  @Field(() => ProfileWhereInput, { nullable: true })
  @Type(() => ProfileWhereInput)
  where?: InstanceType<typeof ProfileWhereInput>;
}

@ArgsType()
export class UpdateOneProfileArgs {
  @Field(() => ProfileUpdateInput, { nullable: false })
  @Type(() => ProfileUpdateInput)
  data!: InstanceType<typeof ProfileUpdateInput>;
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  @Type(() => ProfileWhereUniqueInput)
  where!: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
}

@ArgsType()
export class UpsertOneProfileArgs {
  @Field(() => ProfileWhereUniqueInput, { nullable: false })
  @Type(() => ProfileWhereUniqueInput)
  where!: Prisma.AtLeast<ProfileWhereUniqueInput, 'id' | 'userId'>;
  @Field(() => ProfileCreateInput, { nullable: false })
  @Type(() => ProfileCreateInput)
  create!: InstanceType<typeof ProfileCreateInput>;
  @Field(() => ProfileUpdateInput, { nullable: false })
  @Type(() => ProfileUpdateInput)
  update!: InstanceType<typeof ProfileUpdateInput>;
}

@ObjectType()
export class AggregateTag {
  @Field(() => TagCountAggregate, { nullable: true })
  _count?: InstanceType<typeof TagCountAggregate>;
  @Field(() => TagMinAggregate, { nullable: true })
  _min?: InstanceType<typeof TagMinAggregate>;
  @Field(() => TagMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof TagMaxAggregate>;
}

@ArgsType()
export class CreateManyTagArgs {
  @Field(() => [TagCreateManyInput], { nullable: false })
  @Type(() => TagCreateManyInput)
  data!: Array<TagCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneTagArgs {
  @Field(() => TagCreateInput, { nullable: false })
  @Type(() => TagCreateInput)
  data!: InstanceType<typeof TagCreateInput>;
}

@ArgsType()
export class DeleteManyTagArgs {
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
}

@ArgsType()
export class DeleteOneTagArgs {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
}

@ArgsType()
export class FindFirstTagOrThrowArgs {
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<TagOrderByWithRelationInput>;
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [TagScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof TagScalarFieldEnum>;
}

@ArgsType()
export class FindFirstTagArgs {
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<TagOrderByWithRelationInput>;
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [TagScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof TagScalarFieldEnum>;
}

@ArgsType()
export class FindManyTagArgs {
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<TagOrderByWithRelationInput>;
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [TagScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof TagScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueTagOrThrowArgs {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
}

@ArgsType()
export class FindUniqueTagArgs {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
}

@ArgsType()
export class TagAggregateArgs {
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
  @Field(() => [TagOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<TagOrderByWithRelationInput>;
  @Field(() => TagWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => TagCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof TagCountAggregateInput>;
  @Field(() => TagMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof TagMinAggregateInput>;
  @Field(() => TagMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof TagMaxAggregateInput>;
}

@InputType()
export class TagCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  key?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class TagCountAggregate {
  @Field(() => Int, { nullable: false })
  key!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class TagCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  key?: keyof typeof SortOrder;
}

@ObjectType()
export class TagCount {
  @Field(() => Int, { nullable: false })
  users?: number;
}

@InputType()
export class TagCreateManyInput {
  @Field(() => String, { nullable: false })
  key!: string;
}

@InputType()
export class TagCreateNestedManyWithoutUsersInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateWithoutUsersInput)
  create?: Array<TagCreateWithoutUsersInput>;
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateOrConnectWithoutUsersInput)
  connectOrCreate?: Array<TagCreateOrConnectWithoutUsersInput>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
}

@InputType()
export class TagCreateOrConnectWithoutUsersInput {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => TagCreateWithoutUsersInput, { nullable: false })
  @Type(() => TagCreateWithoutUsersInput)
  create!: InstanceType<typeof TagCreateWithoutUsersInput>;
}

@InputType()
export class TagCreateWithoutUsersInput {
  @Field(() => String, { nullable: false })
  key!: string;
}

@InputType()
export class TagCreateInput {
  @Field(() => String, { nullable: false })
  key!: string;
  @Field(() => UserCreateNestedManyWithoutTagsInput, { nullable: true })
  users?: InstanceType<typeof UserCreateNestedManyWithoutTagsInput>;
}

@ArgsType()
export class TagGroupByArgs {
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
  @Field(() => [TagOrderByWithAggregationInput], { nullable: true })
  orderBy?: Array<TagOrderByWithAggregationInput>;
  @Field(() => [TagScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof TagScalarFieldEnum>;
  @Field(() => TagScalarWhereWithAggregatesInput, { nullable: true })
  having?: InstanceType<typeof TagScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => TagCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof TagCountAggregateInput>;
  @Field(() => TagMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof TagMinAggregateInput>;
  @Field(() => TagMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof TagMaxAggregateInput>;
}

@ObjectType()
export class TagGroupBy {
  @Field(() => String, { nullable: false })
  key!: string;
  @Field(() => TagCountAggregate, { nullable: true })
  _count?: InstanceType<typeof TagCountAggregate>;
  @Field(() => TagMinAggregate, { nullable: true })
  _min?: InstanceType<typeof TagMinAggregate>;
  @Field(() => TagMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof TagMaxAggregate>;
}

@InputType()
export class TagListRelationFilter {
  @Field(() => TagWhereInput, { nullable: true })
  every?: InstanceType<typeof TagWhereInput>;
  @Field(() => TagWhereInput, { nullable: true })
  some?: InstanceType<typeof TagWhereInput>;
  @Field(() => TagWhereInput, { nullable: true })
  none?: InstanceType<typeof TagWhereInput>;
}

@InputType()
export class TagMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  key?: true;
}

@ObjectType()
export class TagMaxAggregate {
  @Field(() => String, { nullable: true })
  key?: string;
}

@InputType()
export class TagMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  key?: keyof typeof SortOrder;
}

@InputType()
export class TagMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  key?: true;
}

@ObjectType()
export class TagMinAggregate {
  @Field(() => String, { nullable: true })
  key?: string;
}

@InputType()
export class TagMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  key?: keyof typeof SortOrder;
}

@InputType()
export class TagOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: keyof typeof SortOrder;
}

@InputType()
export class TagOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  key?: keyof typeof SortOrder;
  @Field(() => TagCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof TagCountOrderByAggregateInput>;
  @Field(() => TagMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof TagMaxOrderByAggregateInput>;
  @Field(() => TagMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof TagMinOrderByAggregateInput>;
}

@InputType()
export class TagOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  key?: keyof typeof SortOrder;
  @Field(() => UserOrderByRelationAggregateInput, { nullable: true })
  users?: InstanceType<typeof UserOrderByRelationAggregateInput>;
}

@InputType()
export class TagScalarWhereWithAggregatesInput {
  @Field(() => [TagScalarWhereWithAggregatesInput], { nullable: true })
  AND?: Array<TagScalarWhereWithAggregatesInput>;
  @Field(() => [TagScalarWhereWithAggregatesInput], { nullable: true })
  OR?: Array<TagScalarWhereWithAggregatesInput>;
  @Field(() => [TagScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: Array<TagScalarWhereWithAggregatesInput>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  key?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class TagScalarWhereInput {
  @Field(() => [TagScalarWhereInput], { nullable: true })
  AND?: Array<TagScalarWhereInput>;
  @Field(() => [TagScalarWhereInput], { nullable: true })
  OR?: Array<TagScalarWhereInput>;
  @Field(() => [TagScalarWhereInput], { nullable: true })
  NOT?: Array<TagScalarWhereInput>;
  @Field(() => StringFilter, { nullable: true })
  key?: InstanceType<typeof StringFilter>;
}

@InputType()
export class TagUncheckedCreateNestedManyWithoutUsersInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateWithoutUsersInput)
  create?: Array<TagCreateWithoutUsersInput>;
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateOrConnectWithoutUsersInput)
  connectOrCreate?: Array<TagCreateOrConnectWithoutUsersInput>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
}

@InputType()
export class TagUncheckedCreateWithoutUsersInput {
  @Field(() => String, { nullable: false })
  key!: string;
}

@InputType()
export class TagUncheckedCreateInput {
  @Field(() => String, { nullable: false })
  key!: string;
  @Field(() => UserUncheckedCreateNestedManyWithoutTagsInput, {
    nullable: true,
  })
  users?: InstanceType<typeof UserUncheckedCreateNestedManyWithoutTagsInput>;
}

@InputType()
export class TagUncheckedUpdateManyWithoutUsersNestedInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateWithoutUsersInput)
  create?: Array<TagCreateWithoutUsersInput>;
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateOrConnectWithoutUsersInput)
  connectOrCreate?: Array<TagCreateOrConnectWithoutUsersInput>;
  @HideField()
  upsert?: Array<TagUpsertWithWhereUniqueWithoutUsersInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagUpdateWithWhereUniqueWithoutUsersInput], { nullable: true })
  @Type(() => TagUpdateWithWhereUniqueWithoutUsersInput)
  update?: Array<TagUpdateWithWhereUniqueWithoutUsersInput>;
  @HideField()
  updateMany?: Array<TagUpdateManyWithWhereWithoutUsersInput>;
  @HideField()
  deleteMany?: Array<TagScalarWhereInput>;
}

@InputType()
export class TagUncheckedUpdateManyWithoutUsersInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class TagUncheckedUpdateManyInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class TagUncheckedUpdateWithoutUsersInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class TagUncheckedUpdateInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => UserUncheckedUpdateManyWithoutTagsNestedInput, {
    nullable: true,
  })
  users?: InstanceType<typeof UserUncheckedUpdateManyWithoutTagsNestedInput>;
}

@InputType()
export class TagUpdateManyMutationInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class TagUpdateManyWithWhereWithoutUsersInput {
  @Field(() => TagScalarWhereInput, { nullable: false })
  @Type(() => TagScalarWhereInput)
  where!: InstanceType<typeof TagScalarWhereInput>;
  @Field(() => TagUpdateManyMutationInput, { nullable: false })
  @Type(() => TagUpdateManyMutationInput)
  data!: InstanceType<typeof TagUpdateManyMutationInput>;
}

@InputType()
export class TagUpdateManyWithoutUsersNestedInput {
  @Field(() => [TagCreateWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateWithoutUsersInput)
  create?: Array<TagCreateWithoutUsersInput>;
  @Field(() => [TagCreateOrConnectWithoutUsersInput], { nullable: true })
  @Type(() => TagCreateOrConnectWithoutUsersInput)
  connectOrCreate?: Array<TagCreateOrConnectWithoutUsersInput>;
  @HideField()
  upsert?: Array<TagUpsertWithWhereUniqueWithoutUsersInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagWhereUniqueInput], { nullable: true })
  @Type(() => TagWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<TagWhereUniqueInput, 'key'>>;
  @Field(() => [TagUpdateWithWhereUniqueWithoutUsersInput], { nullable: true })
  @Type(() => TagUpdateWithWhereUniqueWithoutUsersInput)
  update?: Array<TagUpdateWithWhereUniqueWithoutUsersInput>;
  @HideField()
  updateMany?: Array<TagUpdateManyWithWhereWithoutUsersInput>;
  @HideField()
  deleteMany?: Array<TagScalarWhereInput>;
}

@InputType()
export class TagUpdateWithWhereUniqueWithoutUsersInput {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => TagUpdateWithoutUsersInput, { nullable: false })
  @Type(() => TagUpdateWithoutUsersInput)
  data!: InstanceType<typeof TagUpdateWithoutUsersInput>;
}

@InputType()
export class TagUpdateWithoutUsersInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class TagUpdateInput {
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  key?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => UserUpdateManyWithoutTagsNestedInput, { nullable: true })
  users?: InstanceType<typeof UserUpdateManyWithoutTagsNestedInput>;
}

@InputType()
export class TagUpsertWithWhereUniqueWithoutUsersInput {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => TagUpdateWithoutUsersInput, { nullable: false })
  @Type(() => TagUpdateWithoutUsersInput)
  update!: InstanceType<typeof TagUpdateWithoutUsersInput>;
  @Field(() => TagCreateWithoutUsersInput, { nullable: false })
  @Type(() => TagCreateWithoutUsersInput)
  create!: InstanceType<typeof TagCreateWithoutUsersInput>;
}

@InputType()
export class TagWhereUniqueInput {
  @Field(() => String, { nullable: true })
  key!: string;
  @Field(() => [TagWhereInput], { nullable: true })
  AND?: Array<TagWhereInput>;
  @Field(() => [TagWhereInput], { nullable: true })
  OR?: Array<TagWhereInput>;
  @Field(() => [TagWhereInput], { nullable: true })
  NOT?: Array<TagWhereInput>;
  @Field(() => UserListRelationFilter, { nullable: true })
  users?: InstanceType<typeof UserListRelationFilter>;
}

@InputType()
export class TagWhereInput {
  @Field(() => [TagWhereInput], { nullable: true })
  AND?: Array<TagWhereInput>;
  @Field(() => [TagWhereInput], { nullable: true })
  OR?: Array<TagWhereInput>;
  @Field(() => [TagWhereInput], { nullable: true })
  NOT?: Array<TagWhereInput>;
  @Field(() => StringFilter, { nullable: true })
  key?: InstanceType<typeof StringFilter>;
  @Field(() => UserListRelationFilter, { nullable: true })
  users?: InstanceType<typeof UserListRelationFilter>;
}

@ObjectType()
export class Tag {
  @Field(() => String, { nullable: false, description: '' })
  key!: string;
  @Field(() => [User], { nullable: true, description: '' })
  users?: Array<User>;
}

@ArgsType()
export class UpdateManyTagArgs {
  @Field(() => TagUpdateManyMutationInput, { nullable: false })
  @Type(() => TagUpdateManyMutationInput)
  data!: InstanceType<typeof TagUpdateManyMutationInput>;
  @Field(() => TagWhereInput, { nullable: true })
  @Type(() => TagWhereInput)
  where?: InstanceType<typeof TagWhereInput>;
}

@ArgsType()
export class UpdateOneTagArgs {
  @Field(() => TagUpdateInput, { nullable: false })
  @Type(() => TagUpdateInput)
  data!: InstanceType<typeof TagUpdateInput>;
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
}

@ArgsType()
export class UpsertOneTagArgs {
  @Field(() => TagWhereUniqueInput, { nullable: false })
  @Type(() => TagWhereUniqueInput)
  where!: Prisma.AtLeast<TagWhereUniqueInput, 'key'>;
  @Field(() => TagCreateInput, { nullable: false })
  @Type(() => TagCreateInput)
  create!: InstanceType<typeof TagCreateInput>;
  @Field(() => TagUpdateInput, { nullable: false })
  @Type(() => TagUpdateInput)
  update!: InstanceType<typeof TagUpdateInput>;
}

@ObjectType()
export class AggregateUser {
  @Field(() => UserCountAggregate, { nullable: true })
  _count?: InstanceType<typeof UserCountAggregate>;
  @Field(() => UserAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof UserAvgAggregate>;
  @Field(() => UserSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof UserSumAggregate>;
  @Field(() => UserMinAggregate, { nullable: true })
  _min?: InstanceType<typeof UserMinAggregate>;
  @Field(() => UserMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof UserMaxAggregate>;
}

@ArgsType()
export class CreateManyUserArgs {
  @Field(() => [UserCreateManyInput], { nullable: false })
  @Type(() => UserCreateManyInput)
  data!: Array<UserCreateManyInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@ArgsType()
export class CreateOneUserArgs {
  @Field(() => UserCreateInput, { nullable: false })
  @Type(() => UserCreateInput)
  data!: InstanceType<typeof UserCreateInput>;
}

@ArgsType()
export class DeleteManyUserArgs {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
}

@ArgsType()
export class DeleteOneUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@ArgsType()
export class FindFirstUserOrThrowArgs {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<UserOrderByWithRelationInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [UserScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindFirstUserArgs {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<UserOrderByWithRelationInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [UserScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindManyUserArgs {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<UserOrderByWithRelationInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => [UserScalarFieldEnum], { nullable: true })
  distinct?: Array<keyof typeof UserScalarFieldEnum>;
}

@ArgsType()
export class FindUniqueUserOrThrowArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@ArgsType()
export class FindUniqueUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@ArgsType()
export class UpdateManyUserArgs {
  @Field(() => UserUpdateManyMutationInput, { nullable: false })
  @Type(() => UserUpdateManyMutationInput)
  data!: InstanceType<typeof UserUpdateManyMutationInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
}

@ArgsType()
export class UpdateOneUserArgs {
  @Field(() => UserUpdateInput, { nullable: false })
  @Type(() => UserUpdateInput)
  data!: InstanceType<typeof UserUpdateInput>;
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@ArgsType()
export class UpsertOneUserArgs {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateInput, { nullable: false })
  @Type(() => UserCreateInput)
  create!: InstanceType<typeof UserCreateInput>;
  @Field(() => UserUpdateInput, { nullable: false })
  @Type(() => UserUpdateInput)
  update!: InstanceType<typeof UserUpdateInput>;
}

@ArgsType()
export class UserAggregateArgs {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => [UserOrderByWithRelationInput], { nullable: true })
  orderBy?: Array<UserOrderByWithRelationInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  cursor?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => UserCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof UserCountAggregateInput>;
  @Field(() => UserAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof UserAvgAggregateInput>;
  @Field(() => UserSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof UserSumAggregateInput>;
  @Field(() => UserMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof UserMinAggregateInput>;
  @Field(() => UserMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof UserMaxAggregateInput>;
}

@InputType()
export class UserAvgAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  parentId?: true;
}

@ObjectType()
export class UserAvgAggregate {
  @Field(() => Float, { nullable: true })
  id?: number;
  @Field(() => Float, { nullable: true })
  parentId?: number;
}

@InputType()
export class UserAvgOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: keyof typeof SortOrder;
}

@InputType()
export class UserCountAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  email?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  role?: true;
  @Field(() => Boolean, { nullable: true })
  parentId?: true;
  @Field(() => Boolean, { nullable: true })
  mappedField?: true;
  @Field(() => Boolean, { nullable: true })
  _all?: true;
}

@ObjectType()
export class UserCountAggregate {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Int, { nullable: false })
  createdAt!: number;
  @Field(() => Int, { nullable: false })
  updatedAt!: number;
  @Field(() => Int, { nullable: false })
  email!: number;
  @Field(() => Int, { nullable: false })
  name!: number;
  @Field(() => Int, { nullable: false })
  role!: number;
  @Field(() => Int, { nullable: false })
  parentId!: number;
  @Field(() => Int, { nullable: false })
  mappedField!: number;
  @Field(() => Int, { nullable: false })
  _all!: number;
}

@InputType()
export class UserCountOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: keyof typeof SortOrder;
}

@ObjectType()
export class UserCount {
  @Field(() => Int, { nullable: false })
  posts?: number;
  @Field(() => Int, { nullable: false })
  children?: number;
  @Field(() => Int, { nullable: false })
  anotherPosts?: number;
  @Field(() => Int, { nullable: false })
  tags?: number;
}

@InputType()
export class UserCreateManyParentInputEnvelope {
  @Field(() => [UserCreateManyParentInput], { nullable: false })
  @Type(() => UserCreateManyParentInput)
  data!: Array<UserCreateManyParentInput>;
  @Field(() => Boolean, { nullable: true })
  skipDuplicates?: boolean;
}

@InputType()
export class UserCreateManyParentInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
}

@InputType()
export class UserCreateManyInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
}

@InputType()
export class UserCreateNestedManyWithoutParentInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  @Type(() => UserCreateWithoutParentInput)
  create?: Array<UserCreateWithoutParentInput>;
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutParentInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutParentInput>;
  @HideField()
  createMany?: InstanceType<typeof UserCreateManyParentInputEnvelope>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
}

@InputType()
export class UserCreateNestedManyWithoutTagsInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateWithoutTagsInput)
  create?: Array<UserCreateWithoutTagsInput>;
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutTagsInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutTagsInput>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
}

@InputType()
export class UserCreateNestedOneWithoutAnotherPostsInput {
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: true })
  @Type(() => UserCreateWithoutAnotherPostsInput)
  create?: InstanceType<typeof UserCreateWithoutAnotherPostsInput>;
  @Field(() => UserCreateOrConnectWithoutAnotherPostsInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutAnotherPostsInput)
  connectOrCreate?: InstanceType<
    typeof UserCreateOrConnectWithoutAnotherPostsInput
  >;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@InputType()
export class UserCreateNestedOneWithoutChildrenInput {
  @Field(() => UserCreateWithoutChildrenInput, { nullable: true })
  @Type(() => UserCreateWithoutChildrenInput)
  create?: InstanceType<typeof UserCreateWithoutChildrenInput>;
  @Field(() => UserCreateOrConnectWithoutChildrenInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutChildrenInput)
  connectOrCreate?: InstanceType<
    typeof UserCreateOrConnectWithoutChildrenInput
  >;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@InputType()
export class UserCreateNestedOneWithoutPostsInput {
  @Field(() => UserCreateWithoutPostsInput, { nullable: true })
  @Type(() => UserCreateWithoutPostsInput)
  create?: InstanceType<typeof UserCreateWithoutPostsInput>;
  @Field(() => UserCreateOrConnectWithoutPostsInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutPostsInput)
  connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutPostsInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@InputType()
export class UserCreateNestedOneWithoutProfileInput {
  @Field(() => UserCreateWithoutProfileInput, { nullable: true })
  @Type(() => UserCreateWithoutProfileInput)
  create?: InstanceType<typeof UserCreateWithoutProfileInput>;
  @Field(() => UserCreateOrConnectWithoutProfileInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutProfileInput)
  connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutProfileInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
}

@InputType()
export class UserCreateOrConnectWithoutAnotherPostsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: false })
  @Type(() => UserCreateWithoutAnotherPostsInput)
  create!: InstanceType<typeof UserCreateWithoutAnotherPostsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutChildrenInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateWithoutChildrenInput, { nullable: false })
  @Type(() => UserCreateWithoutChildrenInput)
  create!: InstanceType<typeof UserCreateWithoutChildrenInput>;
}

@InputType()
export class UserCreateOrConnectWithoutParentInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateWithoutParentInput, { nullable: false })
  @Type(() => UserCreateWithoutParentInput)
  create!: InstanceType<typeof UserCreateWithoutParentInput>;
}

@InputType()
export class UserCreateOrConnectWithoutPostsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateWithoutPostsInput, { nullable: false })
  @Type(() => UserCreateWithoutPostsInput)
  create!: InstanceType<typeof UserCreateWithoutPostsInput>;
}

@InputType()
export class UserCreateOrConnectWithoutProfileInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateWithoutProfileInput, { nullable: false })
  @Type(() => UserCreateWithoutProfileInput)
  create!: InstanceType<typeof UserCreateWithoutProfileInput>;
}

@InputType()
export class UserCreateOrConnectWithoutTagsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserCreateWithoutTagsInput, { nullable: false })
  @Type(() => UserCreateWithoutTagsInput)
  create!: InstanceType<typeof UserCreateWithoutTagsInput>;
}

@InputType()
export class UserCreateWithoutAnotherPostsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: InstanceType<typeof UserCreateNestedOneWithoutChildrenInput>;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: InstanceType<typeof UserCreateNestedManyWithoutParentInput>;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: InstanceType<typeof TagCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: InstanceType<typeof ProfileCreateNestedOneWithoutUserInput>;
}

@InputType()
export class UserCreateWithoutChildrenInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: InstanceType<typeof UserCreateNestedOneWithoutChildrenInput>;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: InstanceType<typeof TagCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: InstanceType<typeof ProfileCreateNestedOneWithoutUserInput>;
}

@InputType()
export class UserCreateWithoutParentInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: InstanceType<typeof UserCreateNestedManyWithoutParentInput>;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: InstanceType<typeof TagCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: InstanceType<typeof ProfileCreateNestedOneWithoutUserInput>;
}

@InputType()
export class UserCreateWithoutPostsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: InstanceType<typeof UserCreateNestedOneWithoutChildrenInput>;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: InstanceType<typeof UserCreateNestedManyWithoutParentInput>;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: InstanceType<typeof TagCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: InstanceType<typeof ProfileCreateNestedOneWithoutUserInput>;
}

@InputType()
export class UserCreateWithoutProfileInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: InstanceType<typeof UserCreateNestedOneWithoutChildrenInput>;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: InstanceType<typeof UserCreateNestedManyWithoutParentInput>;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: InstanceType<typeof TagCreateNestedManyWithoutUsersInput>;
}

@InputType()
export class UserCreateWithoutTagsInput {
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: InstanceType<typeof UserCreateNestedOneWithoutChildrenInput>;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: InstanceType<typeof UserCreateNestedManyWithoutParentInput>;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: InstanceType<typeof ProfileCreateNestedOneWithoutUserInput>;
}

@InputType()
export class UserCreateInput {
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostCreateNestedManyWithoutAuthorInput, { nullable: true })
  posts?: InstanceType<typeof PostCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserCreateNestedOneWithoutChildrenInput, { nullable: true })
  parent?: InstanceType<typeof UserCreateNestedOneWithoutChildrenInput>;
  @Field(() => UserCreateNestedManyWithoutParentInput, { nullable: true })
  children?: InstanceType<typeof UserCreateNestedManyWithoutParentInput>;
  @Field(() => PostCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagCreateNestedManyWithoutUsersInput, { nullable: true })
  tags?: InstanceType<typeof TagCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileCreateNestedOneWithoutUserInput, { nullable: true })
  profile?: InstanceType<typeof ProfileCreateNestedOneWithoutUserInput>;
}

@ArgsType()
export class UserGroupByArgs {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => [UserOrderByWithAggregationInput], { nullable: true })
  orderBy?: Array<UserOrderByWithAggregationInput>;
  @Field(() => [UserScalarFieldEnum], { nullable: false })
  by!: Array<keyof typeof UserScalarFieldEnum>;
  @Field(() => UserScalarWhereWithAggregatesInput, { nullable: true })
  having?: InstanceType<typeof UserScalarWhereWithAggregatesInput>;
  @Field(() => Int, { nullable: true })
  take?: number;
  @Field(() => Int, { nullable: true })
  skip?: number;
  @Field(() => UserCountAggregateInput, { nullable: true })
  _count?: InstanceType<typeof UserCountAggregateInput>;
  @Field(() => UserAvgAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof UserAvgAggregateInput>;
  @Field(() => UserSumAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof UserSumAggregateInput>;
  @Field(() => UserMinAggregateInput, { nullable: true })
  _min?: InstanceType<typeof UserMinAggregateInput>;
  @Field(() => UserMaxAggregateInput, { nullable: true })
  _max?: InstanceType<typeof UserMaxAggregateInput>;
}

@ObjectType()
export class UserGroupBy {
  @Field(() => Int, { nullable: false })
  id!: number;
  @Field(() => Date, { nullable: false })
  createdAt!: Date | string;
  @Field(() => Date, { nullable: false })
  updatedAt!: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: false })
  role!: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => UserCountAggregate, { nullable: true })
  _count?: InstanceType<typeof UserCountAggregate>;
  @Field(() => UserAvgAggregate, { nullable: true })
  _avg?: InstanceType<typeof UserAvgAggregate>;
  @Field(() => UserSumAggregate, { nullable: true })
  _sum?: InstanceType<typeof UserSumAggregate>;
  @Field(() => UserMinAggregate, { nullable: true })
  _min?: InstanceType<typeof UserMinAggregate>;
  @Field(() => UserMaxAggregate, { nullable: true })
  _max?: InstanceType<typeof UserMaxAggregate>;
}

@InputType()
export class UserListRelationFilter {
  @Field(() => UserWhereInput, { nullable: true })
  every?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserWhereInput, { nullable: true })
  some?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserWhereInput, { nullable: true })
  none?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserMaxAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  email?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  role?: true;
  @Field(() => Boolean, { nullable: true })
  parentId?: true;
  @Field(() => Boolean, { nullable: true })
  mappedField?: true;
}

@ObjectType()
export class UserMaxAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  email?: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: true })
  mappedField?: string;
}

@InputType()
export class UserMaxOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: keyof typeof SortOrder;
}

@InputType()
export class UserMinAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  createdAt?: true;
  @Field(() => Boolean, { nullable: true })
  updatedAt?: true;
  @Field(() => Boolean, { nullable: true })
  email?: true;
  @Field(() => Boolean, { nullable: true })
  name?: true;
  @Field(() => Boolean, { nullable: true })
  role?: true;
  @Field(() => Boolean, { nullable: true })
  parentId?: true;
  @Field(() => Boolean, { nullable: true })
  mappedField?: true;
}

@ObjectType()
export class UserMinAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: true })
  email?: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: true })
  mappedField?: string;
}

@InputType()
export class UserMinOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  name?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  role?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: keyof typeof SortOrder;
}

@InputType()
export class UserOrderByRelationAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  _count?: keyof typeof SortOrder;
}

@InputType()
export class UserOrderByWithAggregationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  name?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  role?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  parentId?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: keyof typeof SortOrder;
  @Field(() => UserCountOrderByAggregateInput, { nullable: true })
  _count?: InstanceType<typeof UserCountOrderByAggregateInput>;
  @Field(() => UserAvgOrderByAggregateInput, { nullable: true })
  _avg?: InstanceType<typeof UserAvgOrderByAggregateInput>;
  @Field(() => UserMaxOrderByAggregateInput, { nullable: true })
  _max?: InstanceType<typeof UserMaxOrderByAggregateInput>;
  @Field(() => UserMinOrderByAggregateInput, { nullable: true })
  _min?: InstanceType<typeof UserMinOrderByAggregateInput>;
  @Field(() => UserSumOrderByAggregateInput, { nullable: true })
  _sum?: InstanceType<typeof UserSumOrderByAggregateInput>;
}

@InputType()
export class UserOrderByWithRelationInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  createdAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  updatedAt?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  email?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  name?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  role?: keyof typeof SortOrder;
  @Field(() => SortOrderInput, { nullable: true })
  parentId?: InstanceType<typeof SortOrderInput>;
  @Field(() => SortOrder, { nullable: true })
  mappedField?: keyof typeof SortOrder;
  @Field(() => PostOrderByRelationAggregateInput, { nullable: true })
  posts?: InstanceType<typeof PostOrderByRelationAggregateInput>;
  @Field(() => UserOrderByWithRelationInput, { nullable: true })
  parent?: InstanceType<typeof UserOrderByWithRelationInput>;
  @Field(() => UserOrderByRelationAggregateInput, { nullable: true })
  children?: InstanceType<typeof UserOrderByRelationAggregateInput>;
  @Field(() => PostOrderByRelationAggregateInput, { nullable: true })
  anotherPosts?: InstanceType<typeof PostOrderByRelationAggregateInput>;
  @Field(() => TagOrderByRelationAggregateInput, { nullable: true })
  tags?: InstanceType<typeof TagOrderByRelationAggregateInput>;
  @Field(() => ProfileOrderByWithRelationInput, { nullable: true })
  profile?: InstanceType<typeof ProfileOrderByWithRelationInput>;
}

@InputType()
export class UserRelationFilter {
  @Field(() => UserWhereInput, { nullable: true })
  is?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserWhereInput, { nullable: true })
  isNot?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserScalarWhereWithAggregatesInput {
  @Field(() => [UserScalarWhereWithAggregatesInput], { nullable: true })
  AND?: Array<UserScalarWhereWithAggregatesInput>;
  @Field(() => [UserScalarWhereWithAggregatesInput], { nullable: true })
  OR?: Array<UserScalarWhereWithAggregatesInput>;
  @Field(() => [UserScalarWhereWithAggregatesInput], { nullable: true })
  NOT?: Array<UserScalarWhereWithAggregatesInput>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  id?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => DateTimeWithAggregatesFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  email?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  name?: InstanceType<typeof StringWithAggregatesFilter>;
  @Field(() => EnumUserRoleWithAggregatesFilter, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleWithAggregatesFilter>;
  @Field(() => IntWithAggregatesFilter, { nullable: true })
  parentId?: InstanceType<typeof IntWithAggregatesFilter>;
  @Field(() => StringWithAggregatesFilter, { nullable: true })
  mappedField?: InstanceType<typeof StringWithAggregatesFilter>;
}

@InputType()
export class UserScalarWhereInput {
  @Field(() => [UserScalarWhereInput], { nullable: true })
  AND?: Array<UserScalarWhereInput>;
  @Field(() => [UserScalarWhereInput], { nullable: true })
  OR?: Array<UserScalarWhereInput>;
  @Field(() => [UserScalarWhereInput], { nullable: true })
  NOT?: Array<UserScalarWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  email?: InstanceType<typeof StringFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFilter>;
  @Field(() => IntFilter, { nullable: true })
  parentId?: InstanceType<typeof IntFilter>;
  @Field(() => StringFilter, { nullable: true })
  mappedField?: InstanceType<typeof StringFilter>;
}

@InputType()
export class UserSumAggregateInput {
  @Field(() => Boolean, { nullable: true })
  id?: true;
  @Field(() => Boolean, { nullable: true })
  parentId?: true;
}

@ObjectType()
export class UserSumAggregate {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Int, { nullable: true })
  parentId?: number;
}

@InputType()
export class UserSumOrderByAggregateInput {
  @Field(() => SortOrder, { nullable: true })
  id?: keyof typeof SortOrder;
  @Field(() => SortOrder, { nullable: true })
  parentId?: keyof typeof SortOrder;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutParentInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  @Type(() => UserCreateWithoutParentInput)
  create?: Array<UserCreateWithoutParentInput>;
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutParentInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutParentInput>;
  @HideField()
  createMany?: InstanceType<typeof UserCreateManyParentInputEnvelope>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
}

@InputType()
export class UserUncheckedCreateNestedManyWithoutTagsInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateWithoutTagsInput)
  create?: Array<UserCreateWithoutTagsInput>;
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutTagsInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutTagsInput>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
}

@InputType()
export class UserUncheckedCreateWithoutAnotherPostsInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutAuthorInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserUncheckedCreateNestedManyWithoutParentInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedCreateNestedManyWithoutParentInput
  >;
  @Field(() => TagUncheckedCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileUncheckedCreateNestedOneWithoutUserInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedCreateNestedOneWithoutUserInput
  >;
}

@InputType()
export class UserUncheckedCreateWithoutChildrenInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutAuthorInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedCreateNestedManyWithoutAuthorInput>;
  @Field(() => PostUncheckedCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagUncheckedCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileUncheckedCreateNestedOneWithoutUserInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedCreateNestedOneWithoutUserInput
  >;
}

@InputType()
export class UserUncheckedCreateWithoutParentInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutAuthorInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserUncheckedCreateNestedManyWithoutParentInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedCreateNestedManyWithoutParentInput
  >;
  @Field(() => PostUncheckedCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagUncheckedCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileUncheckedCreateNestedOneWithoutUserInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedCreateNestedOneWithoutUserInput
  >;
}

@InputType()
export class UserUncheckedCreateWithoutPostsInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => UserUncheckedCreateNestedManyWithoutParentInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedCreateNestedManyWithoutParentInput
  >;
  @Field(() => PostUncheckedCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagUncheckedCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileUncheckedCreateNestedOneWithoutUserInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedCreateNestedOneWithoutUserInput
  >;
}

@InputType()
export class UserUncheckedCreateWithoutProfileInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutAuthorInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserUncheckedCreateNestedManyWithoutParentInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedCreateNestedManyWithoutParentInput
  >;
  @Field(() => PostUncheckedCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagUncheckedCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedCreateNestedManyWithoutUsersInput>;
}

@InputType()
export class UserUncheckedCreateWithoutTagsInput {
  @Field(() => Int, { nullable: true })
  id?: number;
  @Field(() => Date, { nullable: true })
  createdAt?: Date | string;
  @Field(() => Date, { nullable: true })
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutAuthorInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserUncheckedCreateNestedManyWithoutParentInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedCreateNestedManyWithoutParentInput
  >;
  @Field(() => PostUncheckedCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => ProfileUncheckedCreateNestedOneWithoutUserInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedCreateNestedOneWithoutUserInput
  >;
}

@InputType()
export class UserUncheckedCreateInput {
  @HideField()
  id?: number;
  @HideField()
  createdAt?: Date | string;
  @HideField()
  updatedAt?: Date | string;
  @Field(() => String, { nullable: false })
  email!: string;
  @Field(() => String, { nullable: true })
  name?: string;
  @Field(() => UserRole, { nullable: true })
  role?: keyof typeof UserRole;
  @Field(() => Int, { nullable: true })
  parentId?: number;
  @Field(() => String, { nullable: false })
  mappedField!: string;
  @Field(() => PostUncheckedCreateNestedManyWithoutAuthorInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedCreateNestedManyWithoutAuthorInput>;
  @Field(() => UserUncheckedCreateNestedManyWithoutParentInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedCreateNestedManyWithoutParentInput
  >;
  @Field(() => PostUncheckedCreateNestedManyWithoutAnotherAuthorInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedCreateNestedManyWithoutAnotherAuthorInput
  >;
  @Field(() => TagUncheckedCreateNestedManyWithoutUsersInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedCreateNestedManyWithoutUsersInput>;
  @Field(() => ProfileUncheckedCreateNestedOneWithoutUserInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedCreateNestedOneWithoutUserInput
  >;
}

@InputType()
export class UserUncheckedUpdateManyWithoutParentNestedInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  @Type(() => UserCreateWithoutParentInput)
  create?: Array<UserCreateWithoutParentInput>;
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutParentInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutParentInput>;
  @HideField()
  upsert?: Array<UserUpsertWithWhereUniqueWithoutParentInput>;
  @HideField()
  createMany?: InstanceType<typeof UserCreateManyParentInputEnvelope>;
  @HideField()
  set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserUpdateWithWhereUniqueWithoutParentInput], {
    nullable: true,
  })
  @Type(() => UserUpdateWithWhereUniqueWithoutParentInput)
  update?: Array<UserUpdateWithWhereUniqueWithoutParentInput>;
  @HideField()
  updateMany?: Array<UserUpdateManyWithWhereWithoutParentInput>;
  @HideField()
  deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutParentInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutTagsNestedInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateWithoutTagsInput)
  create?: Array<UserCreateWithoutTagsInput>;
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutTagsInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutTagsInput>;
  @HideField()
  upsert?: Array<UserUpsertWithWhereUniqueWithoutTagsInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserUpdateWithWhereUniqueWithoutTagsInput], { nullable: true })
  @Type(() => UserUpdateWithWhereUniqueWithoutTagsInput)
  update?: Array<UserUpdateWithWhereUniqueWithoutTagsInput>;
  @HideField()
  updateMany?: Array<UserUpdateManyWithWhereWithoutTagsInput>;
  @HideField()
  deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUncheckedUpdateManyWithoutTagsInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateManyInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutAnotherPostsInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAuthorNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUncheckedUpdateManyWithoutParentNestedInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedUpdateManyWithoutParentNestedInput
  >;
  @Field(() => TagUncheckedUpdateManyWithoutUsersNestedInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUncheckedUpdateOneWithoutUserNestedInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedUpdateOneWithoutUserNestedInput
  >;
}

@InputType()
export class UserUncheckedUpdateWithoutChildrenInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAuthorNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedUpdateManyWithoutAuthorNestedInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUncheckedUpdateManyWithoutUsersNestedInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUncheckedUpdateOneWithoutUserNestedInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedUpdateOneWithoutUserNestedInput
  >;
}

@InputType()
export class UserUncheckedUpdateWithoutParentInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAuthorNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUncheckedUpdateManyWithoutParentNestedInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedUpdateManyWithoutParentNestedInput
  >;
  @Field(() => PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUncheckedUpdateManyWithoutUsersNestedInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUncheckedUpdateOneWithoutUserNestedInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedUpdateOneWithoutUserNestedInput
  >;
}

@InputType()
export class UserUncheckedUpdateWithoutPostsInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => UserUncheckedUpdateManyWithoutParentNestedInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedUpdateManyWithoutParentNestedInput
  >;
  @Field(() => PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUncheckedUpdateManyWithoutUsersNestedInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUncheckedUpdateOneWithoutUserNestedInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedUpdateOneWithoutUserNestedInput
  >;
}

@InputType()
export class UserUncheckedUpdateWithoutProfileInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAuthorNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUncheckedUpdateManyWithoutParentNestedInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedUpdateManyWithoutParentNestedInput
  >;
  @Field(() => PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUncheckedUpdateManyWithoutUsersNestedInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedUpdateManyWithoutUsersNestedInput>;
}

@InputType()
export class UserUncheckedUpdateWithoutTagsInput {
  @Field(() => IntFieldUpdateOperationsInput, { nullable: true })
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAuthorNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUncheckedUpdateManyWithoutParentNestedInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedUpdateManyWithoutParentNestedInput
  >;
  @Field(() => PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => ProfileUncheckedUpdateOneWithoutUserNestedInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedUpdateOneWithoutUserNestedInput
  >;
}

@InputType()
export class UserUncheckedUpdateInput {
  @HideField()
  id?: InstanceType<typeof IntFieldUpdateOperationsInput>;
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => NullableIntFieldUpdateOperationsInput, { nullable: true })
  parentId?: InstanceType<typeof NullableIntFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUncheckedUpdateManyWithoutAuthorNestedInput, {
    nullable: true,
  })
  posts?: InstanceType<typeof PostUncheckedUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUncheckedUpdateManyWithoutParentNestedInput, {
    nullable: true,
  })
  children?: InstanceType<
    typeof UserUncheckedUpdateManyWithoutParentNestedInput
  >;
  @Field(() => PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUncheckedUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUncheckedUpdateManyWithoutUsersNestedInput, {
    nullable: true,
  })
  tags?: InstanceType<typeof TagUncheckedUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUncheckedUpdateOneWithoutUserNestedInput, {
    nullable: true,
  })
  profile?: InstanceType<
    typeof ProfileUncheckedUpdateOneWithoutUserNestedInput
  >;
}

@InputType()
export class UserUpdateManyMutationInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutParentInput {
  @Field(() => UserScalarWhereInput, { nullable: false })
  @Type(() => UserScalarWhereInput)
  where!: InstanceType<typeof UserScalarWhereInput>;
  @Field(() => UserUpdateManyMutationInput, { nullable: false })
  @Type(() => UserUpdateManyMutationInput)
  data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithWhereWithoutTagsInput {
  @Field(() => UserScalarWhereInput, { nullable: false })
  @Type(() => UserScalarWhereInput)
  where!: InstanceType<typeof UserScalarWhereInput>;
  @Field(() => UserUpdateManyMutationInput, { nullable: false })
  @Type(() => UserUpdateManyMutationInput)
  data!: InstanceType<typeof UserUpdateManyMutationInput>;
}

@InputType()
export class UserUpdateManyWithoutParentNestedInput {
  @Field(() => [UserCreateWithoutParentInput], { nullable: true })
  @Type(() => UserCreateWithoutParentInput)
  create?: Array<UserCreateWithoutParentInput>;
  @Field(() => [UserCreateOrConnectWithoutParentInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutParentInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutParentInput>;
  @HideField()
  upsert?: Array<UserUpsertWithWhereUniqueWithoutParentInput>;
  @HideField()
  createMany?: InstanceType<typeof UserCreateManyParentInputEnvelope>;
  @HideField()
  set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserUpdateWithWhereUniqueWithoutParentInput], {
    nullable: true,
  })
  @Type(() => UserUpdateWithWhereUniqueWithoutParentInput)
  update?: Array<UserUpdateWithWhereUniqueWithoutParentInput>;
  @HideField()
  updateMany?: Array<UserUpdateManyWithWhereWithoutParentInput>;
  @HideField()
  deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateManyWithoutTagsNestedInput {
  @Field(() => [UserCreateWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateWithoutTagsInput)
  create?: Array<UserCreateWithoutTagsInput>;
  @Field(() => [UserCreateOrConnectWithoutTagsInput], { nullable: true })
  @Type(() => UserCreateOrConnectWithoutTagsInput)
  connectOrCreate?: Array<UserCreateOrConnectWithoutTagsInput>;
  @HideField()
  upsert?: Array<UserUpsertWithWhereUniqueWithoutTagsInput>;
  @HideField()
  set?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  disconnect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  delete?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserWhereUniqueInput], { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Array<Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>>;
  @Field(() => [UserUpdateWithWhereUniqueWithoutTagsInput], { nullable: true })
  @Type(() => UserUpdateWithWhereUniqueWithoutTagsInput)
  update?: Array<UserUpdateWithWhereUniqueWithoutTagsInput>;
  @HideField()
  updateMany?: Array<UserUpdateManyWithWhereWithoutTagsInput>;
  @HideField()
  deleteMany?: Array<UserScalarWhereInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutAnotherPostsNestedInput {
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: true })
  @Type(() => UserCreateWithoutAnotherPostsInput)
  create?: InstanceType<typeof UserCreateWithoutAnotherPostsInput>;
  @Field(() => UserCreateOrConnectWithoutAnotherPostsInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutAnotherPostsInput)
  connectOrCreate?: InstanceType<
    typeof UserCreateOrConnectWithoutAnotherPostsInput
  >;
  @HideField()
  upsert?: InstanceType<typeof UserUpsertWithoutAnotherPostsInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateToOneWithWhereWithoutAnotherPostsInput, {
    nullable: true,
  })
  @Type(() => UserUpdateToOneWithWhereWithoutAnotherPostsInput)
  update?: InstanceType<
    typeof UserUpdateToOneWithWhereWithoutAnotherPostsInput
  >;
}

@InputType()
export class UserUpdateOneRequiredWithoutPostsNestedInput {
  @Field(() => UserCreateWithoutPostsInput, { nullable: true })
  @Type(() => UserCreateWithoutPostsInput)
  create?: InstanceType<typeof UserCreateWithoutPostsInput>;
  @Field(() => UserCreateOrConnectWithoutPostsInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutPostsInput)
  connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutPostsInput>;
  @HideField()
  upsert?: InstanceType<typeof UserUpsertWithoutPostsInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateToOneWithWhereWithoutPostsInput, { nullable: true })
  @Type(() => UserUpdateToOneWithWhereWithoutPostsInput)
  update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutPostsInput>;
}

@InputType()
export class UserUpdateOneRequiredWithoutProfileNestedInput {
  @Field(() => UserCreateWithoutProfileInput, { nullable: true })
  @Type(() => UserCreateWithoutProfileInput)
  create?: InstanceType<typeof UserCreateWithoutProfileInput>;
  @Field(() => UserCreateOrConnectWithoutProfileInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutProfileInput)
  connectOrCreate?: InstanceType<typeof UserCreateOrConnectWithoutProfileInput>;
  @HideField()
  upsert?: InstanceType<typeof UserUpsertWithoutProfileInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateToOneWithWhereWithoutProfileInput, { nullable: true })
  @Type(() => UserUpdateToOneWithWhereWithoutProfileInput)
  update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutProfileInput>;
}

@InputType()
export class UserUpdateOneWithoutChildrenNestedInput {
  @Field(() => UserCreateWithoutChildrenInput, { nullable: true })
  @Type(() => UserCreateWithoutChildrenInput)
  create?: InstanceType<typeof UserCreateWithoutChildrenInput>;
  @Field(() => UserCreateOrConnectWithoutChildrenInput, { nullable: true })
  @Type(() => UserCreateOrConnectWithoutChildrenInput)
  connectOrCreate?: InstanceType<
    typeof UserCreateOrConnectWithoutChildrenInput
  >;
  @HideField()
  upsert?: InstanceType<typeof UserUpsertWithoutChildrenInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  disconnect?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  delete?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserWhereUniqueInput, { nullable: true })
  @Type(() => UserWhereUniqueInput)
  connect?: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateToOneWithWhereWithoutChildrenInput, { nullable: true })
  @Type(() => UserUpdateToOneWithWhereWithoutChildrenInput)
  update?: InstanceType<typeof UserUpdateToOneWithWhereWithoutChildrenInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutAnotherPostsInput {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserUpdateWithoutAnotherPostsInput, { nullable: false })
  @Type(() => UserUpdateWithoutAnotherPostsInput)
  data!: InstanceType<typeof UserUpdateWithoutAnotherPostsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutChildrenInput {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserUpdateWithoutChildrenInput, { nullable: false })
  @Type(() => UserUpdateWithoutChildrenInput)
  data!: InstanceType<typeof UserUpdateWithoutChildrenInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutPostsInput {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserUpdateWithoutPostsInput, { nullable: false })
  @Type(() => UserUpdateWithoutPostsInput)
  data!: InstanceType<typeof UserUpdateWithoutPostsInput>;
}

@InputType()
export class UserUpdateToOneWithWhereWithoutProfileInput {
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
  @Field(() => UserUpdateWithoutProfileInput, { nullable: false })
  @Type(() => UserUpdateWithoutProfileInput)
  data!: InstanceType<typeof UserUpdateWithoutProfileInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutParentInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateWithoutParentInput, { nullable: false })
  @Type(() => UserUpdateWithoutParentInput)
  data!: InstanceType<typeof UserUpdateWithoutParentInput>;
}

@InputType()
export class UserUpdateWithWhereUniqueWithoutTagsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateWithoutTagsInput, { nullable: false })
  @Type(() => UserUpdateWithoutTagsInput)
  data!: InstanceType<typeof UserUpdateWithoutTagsInput>;
}

@InputType()
export class UserUpdateWithoutAnotherPostsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: InstanceType<typeof UserUpdateOneWithoutChildrenNestedInput>;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: InstanceType<typeof UserUpdateManyWithoutParentNestedInput>;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: InstanceType<typeof TagUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: InstanceType<typeof ProfileUpdateOneWithoutUserNestedInput>;
}

@InputType()
export class UserUpdateWithoutChildrenInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: InstanceType<typeof UserUpdateOneWithoutChildrenNestedInput>;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: InstanceType<typeof TagUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: InstanceType<typeof ProfileUpdateOneWithoutUserNestedInput>;
}

@InputType()
export class UserUpdateWithoutParentInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: InstanceType<typeof UserUpdateManyWithoutParentNestedInput>;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: InstanceType<typeof TagUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: InstanceType<typeof ProfileUpdateOneWithoutUserNestedInput>;
}

@InputType()
export class UserUpdateWithoutPostsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: InstanceType<typeof UserUpdateOneWithoutChildrenNestedInput>;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: InstanceType<typeof UserUpdateManyWithoutParentNestedInput>;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: InstanceType<typeof TagUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: InstanceType<typeof ProfileUpdateOneWithoutUserNestedInput>;
}

@InputType()
export class UserUpdateWithoutProfileInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: InstanceType<typeof UserUpdateOneWithoutChildrenNestedInput>;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: InstanceType<typeof UserUpdateManyWithoutParentNestedInput>;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: InstanceType<typeof TagUpdateManyWithoutUsersNestedInput>;
}

@InputType()
export class UserUpdateWithoutTagsInput {
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => DateTimeFieldUpdateOperationsInput, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: InstanceType<typeof UserUpdateOneWithoutChildrenNestedInput>;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: InstanceType<typeof UserUpdateManyWithoutParentNestedInput>;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: InstanceType<typeof ProfileUpdateOneWithoutUserNestedInput>;
}

@InputType()
export class UserUpdateInput {
  @HideField()
  createdAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @HideField()
  updatedAt?: InstanceType<typeof DateTimeFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  email?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => NullableStringFieldUpdateOperationsInput, { nullable: true })
  name?: InstanceType<typeof NullableStringFieldUpdateOperationsInput>;
  @Field(() => EnumUserRoleFieldUpdateOperationsInput, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFieldUpdateOperationsInput>;
  @Field(() => StringFieldUpdateOperationsInput, { nullable: true })
  mappedField?: InstanceType<typeof StringFieldUpdateOperationsInput>;
  @Field(() => PostUpdateManyWithoutAuthorNestedInput, { nullable: true })
  posts?: InstanceType<typeof PostUpdateManyWithoutAuthorNestedInput>;
  @Field(() => UserUpdateOneWithoutChildrenNestedInput, { nullable: true })
  parent?: InstanceType<typeof UserUpdateOneWithoutChildrenNestedInput>;
  @Field(() => UserUpdateManyWithoutParentNestedInput, { nullable: true })
  children?: InstanceType<typeof UserUpdateManyWithoutParentNestedInput>;
  @Field(() => PostUpdateManyWithoutAnotherAuthorNestedInput, {
    nullable: true,
  })
  anotherPosts?: InstanceType<
    typeof PostUpdateManyWithoutAnotherAuthorNestedInput
  >;
  @Field(() => TagUpdateManyWithoutUsersNestedInput, { nullable: true })
  tags?: InstanceType<typeof TagUpdateManyWithoutUsersNestedInput>;
  @Field(() => ProfileUpdateOneWithoutUserNestedInput, { nullable: true })
  profile?: InstanceType<typeof ProfileUpdateOneWithoutUserNestedInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutParentInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateWithoutParentInput, { nullable: false })
  @Type(() => UserUpdateWithoutParentInput)
  update!: InstanceType<typeof UserUpdateWithoutParentInput>;
  @Field(() => UserCreateWithoutParentInput, { nullable: false })
  @Type(() => UserCreateWithoutParentInput)
  create!: InstanceType<typeof UserCreateWithoutParentInput>;
}

@InputType()
export class UserUpsertWithWhereUniqueWithoutTagsInput {
  @Field(() => UserWhereUniqueInput, { nullable: false })
  @Type(() => UserWhereUniqueInput)
  where!: Prisma.AtLeast<UserWhereUniqueInput, 'id' | 'email'>;
  @Field(() => UserUpdateWithoutTagsInput, { nullable: false })
  @Type(() => UserUpdateWithoutTagsInput)
  update!: InstanceType<typeof UserUpdateWithoutTagsInput>;
  @Field(() => UserCreateWithoutTagsInput, { nullable: false })
  @Type(() => UserCreateWithoutTagsInput)
  create!: InstanceType<typeof UserCreateWithoutTagsInput>;
}

@InputType()
export class UserUpsertWithoutAnotherPostsInput {
  @Field(() => UserUpdateWithoutAnotherPostsInput, { nullable: false })
  @Type(() => UserUpdateWithoutAnotherPostsInput)
  update!: InstanceType<typeof UserUpdateWithoutAnotherPostsInput>;
  @Field(() => UserCreateWithoutAnotherPostsInput, { nullable: false })
  @Type(() => UserCreateWithoutAnotherPostsInput)
  create!: InstanceType<typeof UserCreateWithoutAnotherPostsInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutChildrenInput {
  @Field(() => UserUpdateWithoutChildrenInput, { nullable: false })
  @Type(() => UserUpdateWithoutChildrenInput)
  update!: InstanceType<typeof UserUpdateWithoutChildrenInput>;
  @Field(() => UserCreateWithoutChildrenInput, { nullable: false })
  @Type(() => UserCreateWithoutChildrenInput)
  create!: InstanceType<typeof UserCreateWithoutChildrenInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutPostsInput {
  @Field(() => UserUpdateWithoutPostsInput, { nullable: false })
  @Type(() => UserUpdateWithoutPostsInput)
  update!: InstanceType<typeof UserUpdateWithoutPostsInput>;
  @Field(() => UserCreateWithoutPostsInput, { nullable: false })
  @Type(() => UserCreateWithoutPostsInput)
  create!: InstanceType<typeof UserCreateWithoutPostsInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserUpsertWithoutProfileInput {
  @Field(() => UserUpdateWithoutProfileInput, { nullable: false })
  @Type(() => UserUpdateWithoutProfileInput)
  update!: InstanceType<typeof UserUpdateWithoutProfileInput>;
  @Field(() => UserCreateWithoutProfileInput, { nullable: false })
  @Type(() => UserCreateWithoutProfileInput)
  create!: InstanceType<typeof UserCreateWithoutProfileInput>;
  @Field(() => UserWhereInput, { nullable: true })
  @Type(() => UserWhereInput)
  where?: InstanceType<typeof UserWhereInput>;
}

@InputType()
export class UserWhereUniqueInput {
  @Field(() => Int, { nullable: true })
  id!: number;
  @Field(() => String, { nullable: true })
  email!: string;
  @Field(() => [UserWhereInput], { nullable: true })
  AND?: Array<UserWhereInput>;
  @Field(() => [UserWhereInput], { nullable: true })
  OR?: Array<UserWhereInput>;
  @Field(() => [UserWhereInput], { nullable: true })
  NOT?: Array<UserWhereInput>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFilter>;
  @Field(() => IntFilter, { nullable: true })
  parentId?: InstanceType<typeof IntFilter>;
  @Field(() => StringFilter, { nullable: true })
  mappedField?: InstanceType<typeof StringFilter>;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts?: InstanceType<typeof PostListRelationFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  parent?: InstanceType<typeof UserRelationFilter>;
  @Field(() => UserListRelationFilter, { nullable: true })
  children?: InstanceType<typeof UserListRelationFilter>;
  @Field(() => PostListRelationFilter, { nullable: true })
  anotherPosts?: InstanceType<typeof PostListRelationFilter>;
  @Field(() => TagListRelationFilter, { nullable: true })
  tags?: InstanceType<typeof TagListRelationFilter>;
  @Field(() => ProfileRelationFilter, { nullable: true })
  profile?: InstanceType<typeof ProfileRelationFilter>;
}

@InputType()
export class UserWhereInput {
  @Field(() => [UserWhereInput], { nullable: true })
  AND?: Array<UserWhereInput>;
  @Field(() => [UserWhereInput], { nullable: true })
  OR?: Array<UserWhereInput>;
  @Field(() => [UserWhereInput], { nullable: true })
  NOT?: Array<UserWhereInput>;
  @Field(() => IntFilter, { nullable: true })
  id?: InstanceType<typeof IntFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  createdAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => DateTimeFilter, { nullable: true })
  updatedAt?: InstanceType<typeof DateTimeFilter>;
  @Field(() => StringFilter, { nullable: true })
  email?: InstanceType<typeof StringFilter>;
  @Field(() => StringFilter, { nullable: true })
  name?: InstanceType<typeof StringFilter>;
  @Field(() => EnumUserRoleFilter, { nullable: true })
  role?: InstanceType<typeof EnumUserRoleFilter>;
  @Field(() => IntFilter, { nullable: true })
  parentId?: InstanceType<typeof IntFilter>;
  @Field(() => StringFilter, { nullable: true })
  mappedField?: InstanceType<typeof StringFilter>;
  @Field(() => PostListRelationFilter, { nullable: true })
  posts?: InstanceType<typeof PostListRelationFilter>;
  @Field(() => UserRelationFilter, { nullable: true })
  parent?: InstanceType<typeof UserRelationFilter>;
  @Field(() => UserListRelationFilter, { nullable: true })
  children?: InstanceType<typeof UserListRelationFilter>;
  @Field(() => PostListRelationFilter, { nullable: true })
  anotherPosts?: InstanceType<typeof PostListRelationFilter>;
  @Field(() => TagListRelationFilter, { nullable: true })
  tags?: InstanceType<typeof TagListRelationFilter>;
  @Field(() => ProfileRelationFilter, { nullable: true })
  profile?: InstanceType<typeof ProfileRelationFilter>;
}

/**
 * User model documentation
 */
@ObjectType({ description: 'User model documentation' })
export class User {
  @Field(() => Int, { nullable: false, description: '' })
  id!: number;
  @Field(() => Date, { nullable: false, description: '' })
  createdAt!: Date;
  @Field(() => Date, { nullable: false, description: '' })
  updatedAt!: Date;
  /**
   * Email field documentation
   */
  @Field(() => String, {
    nullable: false,
    description: 'Email field documentation',
  })
  email!: string;
  /**
   * Multiple line
   * documentation
   */
  @Field(() => String, {
    nullable: true,
    description: 'Multiple line\ndocumentation',
  })
  name!: string | null;
  @Field(() => UserRole, {
    nullable: false,
    defaultValue: 'USER',
    description: '',
  })
  role!: keyof typeof UserRole;
  @Field(() => Int, { nullable: true, description: '' })
  parentId!: number | null;
  @Field(() => String, { nullable: false, description: '' })
  mappedField!: string;
  /**
   * One to many relation with Post
   */
  @Field(() => [Post], {
    nullable: true,
    description: 'One to many relation with Post',
  })
  posts?: Array<Post>;
  /**
   * Self relation with User
   */
  @Field(() => User, { nullable: true, description: 'Self relation with User' })
  parent?: InstanceType<typeof User> | null;
  /**
   * Self relation with User
   */
  @Field(() => [User], {
    nullable: true,
    description: 'Self relation with User',
  })
  children?: Array<User>;
  /**
   * Another Many to many relation with Post
   */
  @Field(() => [Post], {
    nullable: true,
    description: 'Another Many to many relation with Post',
  })
  anotherPosts?: Array<Post>;
  @Field(() => [Tag], { nullable: true, description: '' })
  tags?: Array<Tag>;
  @Field(() => Profile, { nullable: true, description: '' })
  profile?: InstanceType<typeof Profile> | null;
}
